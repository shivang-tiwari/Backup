# Geany's snippets configuration file for Shivang Tiwari

# use \n or %newline% for a new line (it will be replaced by the used EOL char(s) - LF, CR/LF, CR).
# use \t or %ws% for an indentation step, it will be replaced according to the current document's indent mode.
# use \s to force whitespace at beginning or end of a value ('key= value' won't work, use 'key=\svalue').
# use %key% for all keys defined in the [Special] section.
# use %cursor% to define where the cursor should be placed after completion. You can define multiple
#     %cursor% wildcards and use the "Move cursor in snippet" to jump to the next defined cursor
#     position in the completed snippet.
# You can define a section for each supported filetype to overwrite default settings, the section
# name must match exactly the internal filetype name, run 'geany --ft-names' for a full list.

# Additionally, you can use most of the template wildcards like {developer}, {command:...},
# or {date} in the snippets.
# See the documentation for details.

# For a list of available filetype names, execute:
# geany --ft-names

# Default is used for all filetypes and keys can be overwritten by [filetype] sections
[Default]

# special keys to be used in other snippets, cannot be used "standalone"
# can be used by %key%, e.g. %brace_open%
# nesting of special keys is not supported (e.g. brace_open=\n{\n%brace_close% won't work)
# key "wordchars" is very special, it defines the word delimiting characters when looking for
# a word to auto complete, leave commented to use the default wordchars
[Special]
#brace_open=\n{\n\t
#brace_close=}\n
#block=\n{\n\t%cursor%\n}
block_cursor={\n\t\n}
#wordchars=_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

# Optional keybindings to insert snippets
# Note: these can be overridden by Geany's configurable keybindings
#[Keybindings]
#for=<Ctrl>7


[C++]
# Templates
test=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
notest=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\t//cin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
codejam=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1,casen = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tcout << "Case #" << casen << ": ";\n\t\ttestcase();\n\t\tcasen++;\n\t}\n\treturn (0-0);\n}\n
tester=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define booga cerr << "booga" << endl\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#define safai(...) Clearing_out(__VA_ARGS__)\n\n\ntemplate <typename A, typename B>\n\tstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\n\tstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\n\tstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n\treturn '"' + s + '"';\n}\n\nstring to_string(char c) {\n\tstring s;\n\ts += c;\n\treturn s;\n}\n\nstring to_string(const char* s) {\n\treturn to_string((string) s);\n}\n \nstring to_string(bool b) {\n\treturn (b ? "1" : "0");\n}\n \nstring to_string(vector<bool> v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (int i = 0; i < static_cast<int>(v.size()); i++) {\n\tif (!first) {\n\t\tres += ", ";\n\t}\n\tfirst = false;\n\tres += to_string(v[i]);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n\tstring res = "";\n\tfor (size_t i = 0; i < N; i++) {\n\t\tres += static_cast<char>('0' + v[i]);\n\t}\n\treturn res;\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (const auto &x : v) {\n\t\tif (!first) {\n\t\t\tres += ", ";\n\t\t}\n\t\tfirst = false;\n\t\tres += to_string(x);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n\treturn "(" + to_string(p.first) + ", " + to_string(p.second) + ")";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tcerr << " " << to_string(H);\n\tdebug_out(T...);\n}\n\nvoid Clearing_out() { return; }\n\ntemplate <typename Head, typename... Tail>\nvoid Clearing_out(Head &H, Tail & ... T) {\n\tH.clear();\n\tClearing_out(T...);\n}\nofstream myfile;\n\nvoid testcase(){\n\t%cursor%\n}\n\n\nint main(){\n\tmyfile.open("test_details.txt");\n\tint tt = 1;\n\tcout << tt << endl;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
solve=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nclass solution{\n\tpublic:\n\tvoid testcase(){\n\t\t%cursor%\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tsolution solver;\n\t\tsolver.testcase();\n\t}\n\treturn (0-0);\n}\n
debug=#define ll long long int\n#define ld long double\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 9;\n#endif\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T, typename U> void operator+=(vector<T>& vec, const U value) { for(T &x : vec)x += value; }\ntemplate <typename T, typename U> void operator-=(vector<T>& vec, const U value) { for(T &x : vec)x -= value; }\ntemplate <typename T, typename U> void operator*=(vector<T>& vec, const U value) { for(T &x : vec)x *= value; }\ntemplate <typename T, typename U> void operator/=(vector<T>& vec, const U value) { for(T &x : vec)x /= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,int) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,int) { vec -= 1; }\ntemplate <typename T,typename U, typename V> void operator+=(pair<T,U>& vec, const V value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U, typename V> void operator-=(pair<T,U>& vec, const V value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U, typename V> void operator*=(pair<T,U>& vec, const V value) { vec.first *= value;vec.second *= value; }\ntemplate <typename T,typename U, typename V> void operator/=(pair<T,U>& vec, const V value) { vec.first /= value;vec.second /= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,int) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,int) { vec -= 1; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n
basic=// हर हर महादेव\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\t%cursor%\n\treturn 0;\n}\n
modular=template <typename T>\nT inverse(T a, T m) {\n\tT u = 0, v = 1;\n\twhile (a != 0) {\n\t\tT t = m / a;\n\t\tm -= t * a; swap(a, m);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tassert(m == 1);\n\treturn u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tconstexpr Modular() : value() {}\n\ttemplate <typename U>\n\tModular(const U& x) {\n\t\tvalue = normalize(x);\n\t}\n\ttemplate <typename U>\n\tstatic Type normalize(const U& x) {\n\t\tType v;\n\t\tif (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n\t\telse v = static_cast<Type>(x % mod());\n\t\tif (v < 0) v += mod();\n\t\treturn v;\n\t}\n\tconst Type& operator()() const { return value; }\n\ttemplate <typename U>\n\texplicit operator U() const { return static_cast<U>(value); }\n\tconstexpr static Type mod() { return T::value; }\n\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n\tModular& operator++() { return *this += 1; }\n\tModular& operator--() { return *this -= 1; }\n\tModular operator++(int) { Modular result(*this); *this += 1; return result; }\n\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }\n\tModular operator-() const { return Modular(-value); }\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n\t\tasm(\n\t\t\t"divl %4; "\n\t\t\t: "=a" (d), "=d" (m)\n\t\t\t: "d" (xh), "a" (xl), "r" (mod())\n\t\t);\n\t\tvalue = m;\n#else\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tlong long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n\t\tvalue = normalize(value * rhs.value - q * mod());\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tvalue = normalize(value * rhs.value);\n\t\treturn *this;\n\t}\n\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\tfriend const Type& abs(const Modular& x) { return x.value; }\n\ttemplate <typename U>\n\tfriend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename U>\n\tfriend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename V, typename U>\n\tfriend V& operator>>(V& stream, Modular<U>& number);\n\tprivate: Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n\tassert(b >= 0);\n\tModular<T> x = a, res = 1;\n\tU p = b;\n\twhile (p > 0) {\n\t\tif (p & 1) res *= x;\n\t\tx *= x;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n\treturn number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n\treturn to_string(number());\n}\n \n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n\treturn stream << number();\n}\n \n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n\ttypename common_type<typename Modular<T>::Type, long long>::type x;\n\tstream >> x;\n\tnumber.value = Modular<T>::normalize(x);\n\treturn stream;\n}\n \n\n//using ModType = int;\n \n//struct VarMod { static ModType value; };\n//ModType VarMod::value;\n//ModType& md = VarMod::value;\n//using Mint = Modular<VarMod>;\n \nconstexpr int md = (int) 1e9 + 7;\n//constexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nMint power(int x,const long long int y){\n\treturn power(Mint(x),y);\n}\n/*\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\n\nconst int MXN = ;\n\nvoid prep(){ // Don't forget to call this to use nCr\n\tfact.resize(MXN);\n\tinv_fact.resize(MXN);\n\tfact[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfact[i] = fact[i-1]*i;\n\t}\n\tinv_fact[MXN-1] = power(fact[MXN-1],md-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinv_fact[i] = inv_fact[i+1]*(i+1);\n\t}\n}\n \n\nMint C(int n, int k) {\n\tif (k < 0 || k > n) {\n\t\treturn 0;\n\t}\n\twhile ((int) fact.size() < n + 1) {\n\t\tfact.push_back(fact.back() * (int) fact.size());\n\t\tinv_fact.push_back(1 / fact.back());\n\t}\n\treturn fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n*/\n
geometry=const double EPS = 1e-8, PI = acos(-1);\ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\n\nnamespace geometry { // geometry Library\n\tstruct Point {\n\t\tdouble x, y;\n\t\tPoint(){};\n\t\tPoint(double x_,double y_):x(x_),y(y_){};\n\t\tPoint operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n\t\tPoint operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n\t\tPoint operator*(const double b) const { return Point(x * b,y * b); }\n\t\tPoint operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n\t\tPoint operator/(const double b) const { return Point(x / b,y / b); }\n\t\tbool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n\t\tbool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n\t\tdouble norm(){ return x * x + y * y; }\n\t\tdouble arg(){ return atan2(x,y); }\n\t\tdouble abs(){ return sqrt(norm()); }\n\t\tPoint rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n\t\tPoint rotate90(){ return Point(-y,x); }\n\t\tfriend ostream& operator<<(ostream& os, Point& p){ return os<<p.x<<" "<< p.y; }\n\t\tfriend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n\t};\n\tstruct Line {\n\t\tPoint a, b;\n\t\tLine(){};\n\t\tLine(Point a_,Point b_):a(a_),b(b_){};\n\t\tfriend ostream& operator<<(ostream& os, Line& p){ return os<<"("<<p.a.x<<","<<p.a.y<<") to ("<<p.b.x<<","<<p.b.y<<")"; }\n\t\tfriend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n\t};\n\tstruct Segment {\n\t\tPoint a, b;\n\t\tSegment(){};\n\t\tSegment(Point a_,Point b_):a(a_),b(b_){};\n\t\tfriend ostream& operator<<(ostream& os, Segment& p){ return os<<"("<<p.a.x<<","<<p.a.y<<") to ("<<p.b.x<<","<<p.b.y<<")"; }\n\t\tfriend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n\t};\n\tstruct Circle {\n\t\tPoint p; double r;\n\t\tCircle(){};\n\t\tCircle(Point p_, double r_) : p(p_),r(r_){};\n\t};\n\ttypedef vector< Point > Polygon;\n\ttypedef vector< Segment > Segments;\n\ttypedef vector< Line > Lines;\n\ttypedef vector< Circle > Circles;\n\ttypedef pair< Point, Point > PointPoint;\n\t\n\tdouble cross(const Point& a,const Point& b){return a.x * b.y - a.y * b.x;}\n\tdouble dot(const Point& a,const Point& b){return a.x * b.x + a.y * b.y;}\n\tint ccw(const Point& a,Point b,Point c){b = b - a, c = c - a;if(cross(b,c) > EPS)return +1;if(cross(b,c) < -EPS)return -1;if(dot(b,c) < 0)return +2;if(b.norm() < c.norm())return -2;return 0;}\n\tPoint Projection(const Line& l, const Point& p){double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();return l.a + (l.a - l.b) * t;}\n\tPoint Projection(const Segment& l, const Point& p){double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();return l.a + (l.a - l.b) * t;}\n\tPoint Reflection(const Line& l, const Point& p){return p + (Projection( l, p) - p) * 2.0;}\n\tdouble Distance( const Line& l,const Point& p) {return (p - Projection( l, p)).abs();}\n\tbool Intersect(const Line& l, const Line& m){return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;}\n\tbool Intersect(const Line& l, const Segment& s){return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;}\n\tbool Intersect(const Line& l, const Point& p){return abs(ccw(l.a, l.b, p)) != -1;}\n\tbool Intersect(const Segment& s, const Segment& t){return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;}\n\tbool Intersect(const Segment& s, const Point& p){return ccw(s.a, s.b, p) == 0;}\n\tbool Intersect(const Circle& c,const Line& l){return Distance( l, c.p) <= c.r + EPS;}\n\tbool Intersect(const Circle& c,const Point& p){return abs( ( p - c.p).abs() - c.r ) < EPS;}\n\tint  Intersect(const Circle& c, const Segment& l){if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;if(( d1 < c.r - EPS && d2 > c.r + EPS )|| (d1 > c.r + EPS && d2 < c.r - EPS )) return 1;const Point h = Projection( l, c.p);if( dot( l.a - h, l.b - h) < 0) return 2;return 0;}\n\tbool Intersect(const Circle& a,const Circle& b){return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);}\n\tbool Intersect(const Polygon& Q,const Segment& l){for(int i = 0; i < (int)Q.size(); i++){if(Intersect(Segment(Q[i],Q[(i+1)%Q.size()]),l))return true;}return false;}\n\tdouble Distance(const Segment& s,const Point& p){Point r = Projection(s, p);if ( Intersect( s, r)) return ( r - p).abs();return min( ( s.a - p).abs(), ( s.b - p).abs());}\n\tdouble Distance(const Segment& a,const Segment& b){if(Intersect( a, b)) return 0;return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));}\n\tdouble Distance(const Line& l,const Line& m) {return Intersect( l, m) ? 0 : Distance( l, m.a);}\n\tdouble Distance(const Line& l,const Segment& s) {if (Intersect(l, s)) return 0;return min(Distance(l, s.a), Distance(l, s.b));}\n\tdouble Distance(const Point& a,const Point& b){ return ( a - b).abs();}\n\tPoint Crosspoint(const Segment& l,const Segment& m) { double A = cross(l.b - l.a, m.b - m.a);double B = cross(l.b - l.a, l.b - m.a);if (abs(A) < EPS && abs(B) < EPS) return m.a;return m.a + (m.b - m.a) * B / A;}\n\tPointPoint Crosspoint(const Circle& c,const Line l){Point hp = Projection( l, c.p), h =  hp - c.p;const double d2 = h.norm();Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();return PointPoint(hp - v, hp + v);}\n\tPointPoint Crosspoint(const Circle& c,const Segment& l) {Line aa = Line( l.a, l.b);if(Intersect(c, l) == 2) return Crosspoint(c, aa);PointPoint ret = Crosspoint(c, aa);if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;else ret.first = ret.second;return ret;}\n\tPointPoint Crosspoint(const Circle& c1,const Circle& c2){ double d = (c1.p - c2.p).abs();double s = (c1.r + c2.r + d) / 2;double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));double h = 2 * S / d;Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();double m = sqrt( c1.r * c1.r - h * h);return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);}\n\tbool parallel(const Line& a,const Line& b){return abs(cross( a.b - a.a, b.b - b.a)) < EPS;}\n\tbool orthogonal(const Line& a,const Line& b){return abs(dot( a.a - a.b, b.a - b.b)) < EPS;}\n\tint Contains(const Polygon& Q,const Point& p){bool in = false;for(int i = 0 ; i < (int)Q.size() ; i++ ){Point a = curr(Q,i) - p, b = next(Q,i) - p;if(a.y > b.y) swap(a,b);if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;}return in ? IN : OUT;}\n\tbool Contains(const Circle& c,const Point& p){return ( c.p - p).abs() < c.r + EPS;}\n\tdouble Area2(const Polygon& p){ double A = 0;for (int i = 0; i < (int)p.size(); ++i){A += cross(curr(p, i), next(p, i));}return A;}\n\tbool IsConvex(const Polygon& p){for(int i = 0; i < (int)p.size(); i++){if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;}return true;}\n\tPolygon convexHull(Polygon& p){\n\t\tint n = p.size(), k = 0;\n\t\tif(n >= 3){\n\t\t\tsort( p.begin(), p.end());\n\t\t\tvector< Point > ch(2 * n);\n\t\t\tfor(int i = 0; i < n; ch[k++] = p[i++]){\n\t\t\t\twhile(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n\t\t\t}\n\t\t\tfor(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n\t\t\t\twhile(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n\t\t\t}\n\t\t\tch.resize( k - 1);\n\t\t\treturn ch;\n\t\t} else {\n\t\t\treturn p;\n\t\t}\n\t}\n};\nusing namespace geometry;\n#pragma message("While printing, cast into integer if necessary")\n
pragma=#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n

# Loops and conditionals
if=if(%cursor%)%block_cursor%
else=else{\n\t%cursor%\n}
while=while(%cursor%)%block_cursor%
for=for(int i = 0; i < %cursor%; i++)%block_cursor%
rev=for(int i = %cursor%; i >= 0; i--)%block_cursor%
forj=for(int j = 0; j < %cursor%; j++)%block_cursor%
revj=for(int j = %cursor%; j >= 0; j--)%block_cursor%
fork=for(int k = 0; k < %cursor%; k++)%block_cursor%
revk=for(int k = %cursor%; k >= 0; k--)%block_cursor%
permute=do{\n\t\n} while(next_permutation(%cursor%.begin(),%cursor%.end()));\n

# Data-types
ll=long long int 
ld=long double 
ull=unsigned long long int 
str=string 
pii=pair<int,int> 
pll= pair<ll,ll> 
vec=vector<%cursor%>
set=set<%cursor%>
multi=multiset<%cursor%>
pq=priority_queue<%cursor%>+
vi=vector<int> 
vll=vector<ll> 
vc=vector<char> 
vb=vector<bool> 
vs=vector<string> 
vpii=vector<pair<int,int>> 
vpll=vector<pair<ll,ll>> 
vvi=vector<vector<int>> 
vvll=vector<vector<ll>> 
vvc=vector<vector<char>> 
mpii=map<int,int> 
mpci=map<char,int> 

# Inputs
array=int n;\ncin >> n;\nvector<int> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
arrayll=int n;\ncin >> n;\nvector<ll> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
array2d=int n,m;\ncin >> n >> m;\nvector<vector<int>> a(n,vector<int>(m));\nfor(int i = 0; i < n; i++){\n\tfor(int j = 0; j < m; j++){\n\t\tcin >> a[i][j];\n\t}\n}\n
bord=int n,m;\ncin >> n >> m;\nvector<string> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
graph=int n,m;\ncin >> n >> m;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphw=int n,m;\ncin >> n >> m;\nvector<vector<pair<int,int>>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\t//graph[v].push_back({u,w});\n}\n
graphwg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\tgraph[v].push_back({u,w});\n}\n
tree=int n;\ncin >> n;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
treeg=cin >> n;\ngraph.resize(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
fileio=#ifdef shivang_ka_laptop\n\tfreopen("in.txt" , "r", stdin);\n\tfreopen("out.txt" ,"w", stdout);\n#endif\n

# Structures
segtree=class segtree {\n public:\n\tint neutral = 0;\n\tstruct node {\n\t\t// don't forget to set default value (used for leaves)\n\t\t// not necessarily neutral element!\n\t\t%cursor%; // Set identity element\n\t\tint add = 0;\n\t\tvoid apply(int l, int r, int v) { // Value of a single node (used by build and update)\n\t\t\t%cursor%;\n\t\t\t//sum = v; \n\t\t}\n\t\tvoid push(int l, int r, int v) { // Lazy propogation (used by add)\n\t\t\t//sum += v*(r - l + 1); \n\t\t\t//add += v;\n\t\t}\n\t};\n\tnode unite(const node &a, const node &b) const { // Set combination operation\n\t\tnode res;\n\t\t%cursor%;\n\t\t//res.sum = a.sum + b.sum; \n\t\treturn res;\n\t}\n\tinline void push(int x, int l, int r) {\n\t\t//int y = (l + r) >> 1;\n\t\t//int z = x + ((y - l + 1) << 1);\n\t\t//if (tree[x].add != neutral) {\n\t\t\t//tree[x + 1].push(l, y, tree[x].add);\n\t\t\t//tree[z].push(y + 1, r, tree[x].add);\n\t\t\t//tree[x].add = neutral;\n\t\t//}\n\t\t\n\t\t// Don't forget to uncomment node.push\n\t}\n\tinline void pull(int x, int z) {\n\t\ttree[x] = unite(tree[x + 1], tree[z]);\n\t}\n\n\tint n;\n\tvector<node> tree;\n\tvoid build(int x, int l, int r) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y);\n\t\tbuild(z, y + 1, r);\n\t\tpull(x, z);\n\t}\n\ttemplate <typename M>\n\tvoid build(int x, int l, int r, const vector<M> &v) {\n\t\tif (l == r) {\n\t\t\ttree[x].apply(l, r, v[l]);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y, v);\n\t\tbuild(z, y + 1, r, v);\n\t\tpull(x, z);\n\t}\n\tnode find(int x, int l, int r, int lx, int rx) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\treturn tree[x];\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tnode res{};\n\t\tif (rx <= y) {\n\t\t\tres = find(x + 1, l, y, lx, rx);\n\t\t} else {\n\t\t\tif (lx > y) {\n\t\t\tres = find(z, y + 1, r, lx, rx);\n\t\t\t} else {\n\t\t\tres = unite(find(x + 1, l, y, lx, rx), find(z, y + 1, r, lx, rx));\n\t\t\t}\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\ttemplate <typename... M>\n\tvoid update(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].apply(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tupdate(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tupdate(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].push(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tadd(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tadd(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\tsegtree(int _n) : n(_n) {\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1);\n\t}\n\ttemplate <typename M>\n\tsegtree(const vector<M> &v) {\n\t\tn = v.size();\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1, v);\n\t}\n\tnode find(int p) { // value at index p\n\t\tassert(0 <= p && p <= n - 1);\n\t\treturn find(0, 0, n - 1, p, p);\n\t}\n\ttemplate <typename... M>\n\tvoid update(int lx, int rx, const M&... v) {\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tupdate(0, 0, n - 1, lx, rx, v...);\n\t}\n\t// All functions below\n\tvoid update(int i, int v){ // Sets value at index i to v\n\t\tassert(i >= 0 && i < n);\n\t\tupdate(i,i,v);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int lx, int rx, const M&... v) { // adds v to a[lx to rx]\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tadd(0, 0, n - 1, lx, rx, v...);\n\t}\n\tnode find(int lx, int rx) { // value of lx to rx\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\treturn find(0, 0, n - 1, lx, rx);\n\t}\n};\n
fenwick=template <typename T>\nclass fenwick {\n  public:\n\tvector<T> fenw;\n\tint n;\n\tconst T neutral = 0; // Neutral element\n\tfenwick(int _n) : n(_n) {\n\t\tfenw.resize(n,neutral);\n\t}\n\tvoid add(int x, T v) {\n\t\tassert(x < n && x >= 0);\n\t\twhile (x < n) {\n\t\t\tcombine(fenw[x],v);\n\t\t\tx |= (x + 1);\n\t\t}\n\t}\n\tT find(int x) {\n\t\tassert(x < n && x >= 0);\n\t\tT v = neutral;\n\t\twhile (x >= 0) {\n\t\t\tcombine(v,fenw[x]);\n\t\t\tx = (x & (x + 1)) - 1;\n\t\t}\n\t\treturn v;\n\t}\n\tT find(int l,int r) { // Don't forget to change this if using anything other than addition\n\t\treturn find(r) - (l == 0 ? neutral : find(l-1));\n\t}\n\tvoid combine(T &v, T val){\n\t\t%cursor%;\n\t\t//v += val;\n\t}\n};\n
sparse=template<class T>\nclass sparse{\n\tpublic:\n\tint N, LG;\n\tvector<vector<T>>spt;\n\tvector<int>lg;\n\tsparse(){}\n\tsparse(vector<T> &a){\n\t\tN = a.size();\n\t\tLG = 32 - __builtin_clz(std::max(N - 1, 1));\n\t\tspt.resize(N+1, vector<T>(LG+1));\n\t\tlg.resize(N + 5,0);\n\t\tfor(int i = 2;i <= N;i++)\n\t\t\tlg[i] = lg[i/2] + 1;\n\t\tbuild(a);\n\t}\n\tvoid build(vector<T> &a){\n\t\tfor(int i = 0;i < N;i++)\n\t\t\tspt[i][0] = a[i];\n\t\tfor(int j = 1;j <= LG;j++){\n\t\t\tint len = (1 << j), half = (1 << (j-1));\n\t\t\tfor(int i = 0;i + len <= N;i++)\n\t\t\t\tspt[i][j] = combine(spt[i][j-1],spt[i+half][j-1]);\n\t\t}\n\t}\n\tT find(int l, int r){ // For idempotent operations in O(1)\n\t\tassert(l <= r && l >= 0 && r <= N-1);\n\t\tint lgg = lg[r-l+1], len = (1<<lgg);\n\t\treturn combine(spt[l][lgg], spt[r-len+1][lgg]);\n\t}\n\tT query(int L, int R){ // For other operations in O(log n)\n\t\tT answer = 0;\n\t\tfor (int j = LG; j >= 0; j--) {\n\t\t\tif (L + (1 << j) - 1 <= R) {\n\t\t\t\tanswer = combine(answer,spt[L][j]);\n\t\t\t\tL += 1 << j;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\tT combine(T x,T y){\n\t\treturn %cursor%;\n\t}\n};\n
lca=class LCA{\n\ttemplate<typename T>\n\tstruct SparseTable{\n\t\tvector<vector<T>> table;\n\t\tvector<int> logtable;\n\t\tfunction<T(T, T)> merge_func;\n\t\tSparseTable(){}\n\t\tSparseTable(const vector<T> &vec, const function<T(T, T)> &f): merge_func(f){\n\t\t\tint maxlength = 0;\n\t\t\twhile((1 << (maxlength+1)) <= (int)vec.size()) maxlength++;\n\t\t\ttable.resize(maxlength+1, vector<T>(vec.size()));\n\t\t\tlogtable.resize(vec.size()+1);\n\t\t\tfor(int i = 0;i < maxlength + 1;i++){\n\t\t\t\tfor(int j = 0;j < (int)vec.size() - (1 << i) + 1;j++){\n\t\t\t\t\tif(i)table[i][j] = merge_func(table[i-1][j], table[i-1][j + (1 << (i-1))]);\n\t\t\t\t\telse table[i][j] = vec[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 2;i <= (int)vec.size();i++)logtable[i] = logtable[i >> 1]+1;\n\t\t}\n\t\tT query(int l, int r){\n\t\t\tassert(l < r);\n\t\t\tint length = r - l;\n\t\t\treturn merge_func(table[logtable[length]][l], table[logtable[length]][r - (1 << logtable[length])]);\n\t\t}\n\t};\n\tprivate:\n\tint a = 0, b = 0;\n\tvector<int> begin, number, tour, dep, rev;\n\tSparseTable<int> table;\n\tvoid init_dfs(int v, int p, const vector<vector<int>> &g){\n\t\tnumber[v] = b;rev[b] = v;b++;\n\t\tfor(auto t : g[v]){\n\t\t\tif(t == p) continue;\n\t\t\tdep[t] = dep[v] + 1;\n\t\t\tinit_dfs(t, v, g);\n\t\t\ttour.push_back(number[v]);\n\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t\ta++;\n\t\t}\n\t\tif(begin[v] == -1)begin[v] = a;\n\t}\n\tpublic:\n\t//initialization O(NlogN)\n\tLCA(const vector<vector<int>> &g, int root = 0):begin(g.size(), -1), number(g.size()), dep(g.size(), -1), rev(g.size()){\n\t\tdep[root] = 0;\n\t\tinit_dfs(root, -1, g);\n\t\ttable = SparseTable<int>(tour, [](int x, int y){return min(x, y);});\n\t}\n\t//O(1) per query\n\tint lca(int u, int v){\n\t\tif(begin[u] == begin[v]) return (dep[u] > dep[v] ? v : u);\n\t\tif(begin[u] > begin[v]) swap(u, v);\n\t\t\treturn rev[table.query(begin[u], begin[v]+1)];\n\t}\n\tint depth(int v){\n\t\treturn dep[v];\n\t}\n\tint dist(int u, int v){\n\t\treturn dep[u] + dep[v] - 2*dep[lca(u, v)];\n\t}\n};\n
hld=class HLD{\n\tclass LCA{\n\t\ttemplate<typename T>\n\t\tstruct SparseTable{\n\t\t\tvector<vector<T>> table;\n\t\t\tvector<int> logtable;\n\t\t\tfunction<T(T, T)> merge_func;\n\t\t\tSparseTable(){}\n\t\t\tSparseTable(const vector<T> &vec, const function<T(T, T)> &f): merge_func(f){\n\t\t\t\tint maxlength = 0;\n\t\t\t\twhile((1 << (maxlength+1)) <= (int)vec.size()) maxlength++;\n\t\t\t\ttable.resize(maxlength+1, vector<T>(vec.size()));\n\t\t\t\tlogtable.resize(vec.size()+1);\n\t\t\t\tfor(int i = 0;i < maxlength + 1;i++){\n\t\t\t\t\tfor(int j = 0;j < (int)vec.size() - (1 << i) + 1;j++){\n\t\t\t\t\t\tif(i)table[i][j] = merge_func(table[i-1][j], table[i-1][j + (1 << (i-1))]);\n\t\t\t\t\t\telse table[i][j] = vec[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 2;i <= (int)vec.size();i++)logtable[i] = logtable[i >> 1]+1;\n\t\t\t}\n\t\t\tT query(int l, int r){\n\t\t\t\tassert(l < r);\n\t\t\t\tint length = r - l;\n\t\t\t\treturn merge_func(table[logtable[length]][l], table[logtable[length]][r - (1 << logtable[length])]);\n\t\t\t}\n\t\t};\n\t\tprivate:\n\t\tint a = 0, b = 0;\n\t\tvector<int> begin, number, tour, dep, rev;\n\t\tSparseTable<int> table;\n\t\tvoid init_dfs(int v, int p, const vector<vector<int>> &g){\n\t\t\tnumber[v] = b;rev[b] = v;b++;\n\t\t\tfor(auto t : g[v]){\n\t\t\t\tif(t == p) continue;\n\t\t\t\tdep[t] = dep[v] + 1;\n\t\t\t\tinit_dfs(t, v, g);\n\t\t\t\ttour.push_back(number[v]);\n\t\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(begin[v] == -1)begin[v] = a;\n\t\t}\n\t\tpublic:\n\t\tLCA(){}\n\t\t//initialization O(NlogN)\n\t\tLCA(const vector<vector<int>> &g, int root = 0):begin(g.size(), -1), number(g.size()), dep(g.size(), -1), rev(g.size()){\n\t\t\tdep[root] = 0;\n\t\t\tinit_dfs(root, -1, g);\n\t\t\ttable = SparseTable<int>(tour, [](int x, int y){return min(x, y);});\n\t\t}\n\t\t//O(1) per query\n\t\tint lca(int u, int v){\n\t\t\tif(begin[u] == begin[v]) return (dep[u] > dep[v] ? v : u);\n\t\t\tif(begin[u] > begin[v]) swap(u, v);\n\t\t\t\treturn rev[table.query(begin[u], begin[v]+1)];\n\t\t}\n\t\tint depth(int v){\n\t\t\treturn dep[v];\n\t\t}\n\t\tint dist(int u, int v){\n\t\t\treturn dep[u] + dep[v] - 2*dep[lca(u, v)];\n\t\t}\n\t};\n\t\n\tclass segtree {\n\t public:\n\t\tint neutral = 0;\n\t\tstruct node {\n\t\t\t// don't forget to set default value (used for leaves)\n\t\t\t// not necessarily neutral element!\n\t\t\t%cursor%; // Set identity element\n\t\t\tint add = 0;\n\t\t\tvoid apply(int l, int r, int v) { // Value of a single node (used by build and update)\n\t\t\t\t%cursor%;\n\t\t\t\t//sum = v; \n\t\t\t}\n\t\t\tvoid push(int l, int r, int v) { // Lazy propogation (used by add)\n\t\t\t\t//sum += v*(r - l + 1); \n\t\t\t\t//add += v;\n\t\t\t}\n\t\t};\n\t\tnode unite(const node &a, const node &b) const { // Set combination operation\n\t\t\tnode res;\n\t\t\t%cursor%;\n\t\t\t//res.sum = a.sum + b.sum; \n\t\t\treturn res;\n\t\t}\n\t\tinline void push(int x, int l, int r) {\n\t\t\t//int y = (l + r) >> 1;\n\t\t\t//int z = x + ((y - l + 1) << 1);\n\t\t\t//if (tree[x].add != neutral) {\n\t\t\t\t//tree[x + 1].push(l, y, tree[x].add);\n\t\t\t\t//tree[z].push(y + 1, r, tree[x].add);\n\t\t\t\t//tree[x].add = neutral;\n\t\t\t//}\n\t\t\t\n\t\t\t// Don't forget to uncomment node.push\n\t\t}\n\t\tinline void pull(int x, int z) {\n\t\t\ttree[x] = unite(tree[x + 1], tree[z]);\n\t\t}\n\t\n\t\tint n;\n\t\tvector<node> tree;\n\t\tvoid build(int x, int l, int r) {\n\t\t\tif (l == r) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tbuild(x + 1, l, y);\n\t\t\tbuild(z, y + 1, r);\n\t\t\tpull(x, z);\n\t\t}\n\t\ttemplate <typename M>\n\t\tvoid build(int x, int l, int r, const vector<M> &v) {\n\t\t\tif (l == r) {\n\t\t\t\ttree[x].apply(l, r, v[l]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tbuild(x + 1, l, y, v);\n\t\t\tbuild(z, y + 1, r, v);\n\t\t\tpull(x, z);\n\t\t}\n\t\tnode find(int x, int l, int r, int lx, int rx) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\treturn tree[x];\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tnode res{};\n\t\t\tif (rx <= y) {\n\t\t\t\tres = find(x + 1, l, y, lx, rx);\n\t\t\t} else {\n\t\t\t\tif (lx > y) {\n\t\t\t\tres = find(z, y + 1, r, lx, rx);\n\t\t\t\t} else {\n\t\t\t\tres = unite(find(x + 1, l, y, lx, rx), find(z, y + 1, r, lx, rx));\n\t\t\t\t}\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t\treturn res;\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid update(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\ttree[x].apply(l, r, v...);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tif (lx <= y) {\n\t\t\t\tupdate(x + 1, l, y, lx, rx, v...);\n\t\t\t}\n\t\t\tif (rx > y) {\n\t\t\t\tupdate(z, y + 1, r, lx, rx, v...);\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid add(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\t\tif (lx <= l && r <= rx) {\n\t\t\t\ttree[x].push(l, r, v...);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint y = (l + r) >> 1;\n\t\t\tint z = x + ((y - l + 1) << 1);\n\t\t\tpush(x, l, r);\n\t\t\tif (lx <= y) {\n\t\t\t\tadd(x + 1, l, y, lx, rx, v...);\n\t\t\t}\n\t\t\tif (rx > y) {\n\t\t\t\tadd(z, y + 1, r, lx, rx, v...);\n\t\t\t}\n\t\t\tpull(x, z);\n\t\t}\n\t\tsegtree(){}\n\t\tsegtree(int _n) : n(_n) {\n\t\t\tassert(n > 0);\n\t\t\ttree.resize(2 * n - 1);\n\t\t\tbuild(0, 0, n - 1);\n\t\t}\n\t\ttemplate <typename M>\n\t\tsegtree(const vector<M> &v) {\n\t\t\tn = v.size();\n\t\t\tassert(n > 0);\n\t\t\ttree.resize(2 * n - 1);\n\t\t\tbuild(0, 0, n - 1, v);\n\t\t}\n\t\tnode find(int p) { // value at index p\n\t\t\tassert(0 <= p && p <= n - 1);\n\t\t\treturn find(0, 0, n - 1, p, p);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid update(int lx, int rx, const M&... v) {\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\tupdate(0, 0, n - 1, lx, rx, v...);\n\t\t}\n\t\tvoid add(int i, int v){\n\t\t\tassert(i >= 0 && i < n);\n\t\t\tadd(i,i,v);\n\t\t}\n\t\t// All functions below\n\t\tvoid update(int i, int v){ // Sets value at index i to v\n\t\t\tassert(i >= 0 && i < n);\n\t\t\tupdate(i,i,v);\n\t\t}\n\t\ttemplate <typename... M>\n\t\tvoid add(int lx, int rx, const M&... v) { // adds v to a[lx to rx]\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\tadd(0, 0, n - 1, lx, rx, v...);\n\t\t}\n\t\tnode find(int lx, int rx) { // value of lx to rx\n\t\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\t\treturn find(0, 0, n - 1, lx, rx);\n\t\t}\n\t};\n\t\n\tpublic:\n\tint N;\n\tvector<vector<int>> adj;\n\tvector<int> a;\n\tvector<int> label;\n\tvector<int> par;\n\tvector<int> depth;\n\tvector<int> siz;\n\tvector<int> heavy;\n\tvector<int> chain_head;\n\tint tim;\n\tbool leave_lca;\n\tLCA lca;\n\tsegtree tr;\n\tHLD(const vector<vector<int>> &G,vector<int> &values,bool _leave_lca){\n\t\tadj = G;\n\t\ta = values;\n\t\tN = G.size();\n\t\tlabel.resize(N);\n\t\tdepth.resize(N);\n\t\tpar.resize(N,-1);\n\t\tsiz.resize(N);\n\t\theavy.resize(N,-1);\n\t\tchain_head.resize(N,-1);\n\t\tiota(chain_head.begin(),chain_head.end(),0);\n\t\ttim = 0;\n\t\tleave_lca = _leave_lca;\n\t\tlca = LCA(adj);\n\t\ttr = segtree(N);\n\t\tsub_dfs(0);\n\t\tlabel_dfs(0);\n\t\tchain_dfs(0);\n\t}\n\tvoid sub_dfs(int i,int parent = -1){\n\t\tpar[i] = parent;\n\t\tsiz[i] = 1;\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent){\n\t\t\t\tdepth[v] = 1 + depth[i];\n\t\t\t\tsub_dfs(v,i);\n\t\t\t\tsiz[i] += siz[v];\n\t\t\t\tif(heavy[i] == -1 || siz[heavy[i]] < siz[v]){\n\t\t\t\t\theavy[i] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid label_dfs(int i,int parent = -1){\n\t\ttr.update(tim,a[i]);\n\t\tlabel[i] = tim++;\n\t\tif(heavy[i] != -1)label_dfs(heavy[i],i);\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent && v != heavy[i]){\n\t\t\t\tlabel_dfs(v,i);\n\t\t\t}\n\t\t}\n\t}\n\tvoid chain_dfs(int i,int parent = -1){\n\t\tfor(int v : adj[i]){\n\t\t\tif(v != parent){\n\t\t\t\tif(v == heavy[i]){\n\t\t\t\t\tchain_head[v] = chain_head[i];\n\t\t\t\t}\n\t\t\t\tchain_dfs(v,i);\n\t\t\t}\n\t\t}\n\t}\n\t// All functions below\n\tsegtree::node find(int u,int v,int flag = -1){\n\t\tif(flag == -1){\n\t\t\tflag = leave_lca;\n\t\t}\n\t\tsegtree::node res;\n\t\tif(u == v){\n\t\t\treturn (flag ? res : tr.find(label[u],label[u]));\n\t\t}\n\t\tint lc = lca.lca(u,v);\n\t\tif(flag){\n\t\t\twhile(depth[u] > depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tif(where == lc){\n\t\t\t\t\tres = tr.unite(res,tr.find(label[where]+1,label[u]));\n\t\t\t\t\tu = lc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\t\tu = par[where];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\twhile(u != -1 && depth[u] >= depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\tu = v;\n\t\twhile(depth[u] > depth[lc]){\n\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\tif(where == lc){\n\t\t\t\tres = tr.unite(res,tr.find(label[where]+1,label[u]));\n\t\t\t\tu = lc;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres = tr.unite(res,tr.find(label[where],label[u]));\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid update(int i,int v){\n\t\ttr.update(label[i],v);\n\t}\n\tvoid add(int u,int v,int x, int flag = -1){\n\t\tif(flag == -1)flag = leave_lca;\n\t\tif(u == v){\n\t\t\tif(flag)return;\n\t\t\ttr.add(label[u],label[u],x);\n\t\t\treturn;\n\t\t}\n\t\tint lc = lca.lca(u,v);\n\t\tif(flag){\n\t\t\twhile(depth[u] > depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\tif(where == lc){\n\t\t\t\t\ttr.add(label[where]+1,label[u],x);\n\t\t\t\t\tu = lc;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\t\tu = par[where];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\twhile(u != -1 && depth[u] >= depth[lc]){\n\t\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t\tu = v;\n\t\twhile(depth[u] > depth[lc]){\n\t\t\tint where = (depth[chain_head[u]] <= depth[lc] ? lc : chain_head[u]);\n\t\t\tif(where == lc){\n\t\t\t\ttr.add(label[where]+1,label[u],x);\n\t\t\t\tu = lc;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttr.add(label[where],label[u],x);\n\t\t\t\tu = par[where];\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Set third argument to FALSE for vertex queries and TRUE for edge queries\n
ordset=#include <bits/extc++.h>\nusing namespace __gnu_pbds;\ntemplate <typename A, typename B = std::less <A>> using ordered_set = tree <A, null_type, B, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename A, typename B, typename C = std::less <A>> using ordered_map = tree <A, B, C, rb_tree_tag, tree_order_statistics_node_update>;\n//order_of_key (k) : Number of items strictly smaller than k\n//find_by_order(k) : K-th element in a set (counting from zero)\n
dsu=struct dsu{\n\tint n;\n\tvector<int> parent;\n\tvector<int> siz;\n\tdsu(int sz) : n(sz){\n\t\tparent.resize(n);\n\t\tsiz.resize(n,1);\n\t\tiota(parent.begin(),parent.end(), 0);\n\t}\n\tinline bool cmp(int a, int b){ // Give indices here\n\t\treturn siz[a] < siz[b];\n\t}\n\tinline int find(int x){ // Give index here\n\t\tassert(x >= 0 && x < n);\n\t\treturn (x == parent[x] ? x : (parent[x] = find(parent[x])));\n\t}\n\tbool combine(int a, int b){ // Give indices here, (returns true if a and b are in different sets)\n\t\tassert(min(a,b) >= 0 && max(a,b) < n);\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a != b){\n\t\t\tif(cmp(a,b))swap(a,b);\n\t\t\tparent[b] = a;\n\t\t\tsiz[a] += siz[b];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tinline bool same(int a,int b){ // Returns true if a and b are in same set\n\t\tassert(min(a,b) >= 0 && max(a,b) < n);\n\t\treturn find(a) == find(b);\n\t}\n\tinline int size(int x){ // Returns the size of the set containing a\n\t\tassert(x >= 0 && x < n);\n\t\treturn siz[find(x)];\n\t}\n};\n
cst=template<typename T>\nstruct cst{ // const is important\n\tbool operator()(const T& v1, const T& v2) const {\n\t\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n\t}\n};\n

# Algorithms
dijkstra=vector<long long int> dist;\nvector<int> pre;\nvoid dijkstra(int start,vector<vector<pair<int,int>>> &adj){\n\tdist.clear();dist.resize(adj.size(),1e18);\n\tpre.clear();pre.resize(adj.size(),-1);\n\tpriority_queue<pair<long long int,int>,vector<pair<long long int,int>>,greater<pair<long long int,int>>> que;\n\tque.push({dist[start] = 0, start});\n\twhile (!que.empty()) {\n\t\tauto top = que.top();\n\t\tque.pop();\n\t\tif (top.first != dist[top.second]) continue;\n\t\tfor(auto node : adj[top.second])\n\t\t\tif(dist[node.first] > top.first + node.second) \n\t\t\t\tque.push({dist[node.first] = top.first + node.second, node.first}), pre[node.first] = top.second;\n\t}\n}\n
dijkstrau=vector<int> pre;\nvector<long long int>dist;\nvoid dijkstra(int start,vector<vector<int>> &adj){\n\tdist.clear();dist.resize(adj.size(),1e18);\n\tpre.clear();pre.resize(adj.size(),-1);\n\tqueue<pair<int,int>> que;\n\tque.push({dist[start] = 0, start});\n\twhile (!que.empty()) {\n\t\tauto top = que.front();\n\t\tque.pop();\n\t\tif (top.first != dist[top.second]) continue;\n\t\tfor(auto node : adj[top.second])\n\t\t\tif(dist[node] > top.first + 1) \n\t\t\t\tque.push({dist[node] = top.first + 1, node}), pre[node] = top.second;\n\t}\n}\n
bpcheck=vector<int> col;\nbool bpcheck(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tcol.clear();col.resize(V,-1);\n\tqueue<pair<int,int>> q;\n\tfor(int i = 0; i < V; i++){\n\t\tif(col[i] == -1) {\n\t\t\tq.push({i,0});\n\t\t\tcol[i] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpair<int,int> p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint v = p.first;\n\t\t\t\tint c = p.second;\n\t\t\t\tfor(int j : adj[v]){\n\t\t\t\t\tif(col[j] == c)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif(col[j] == -1){\n\t\t\t\t\t\tcol[j] = c ^ 0 ^ 1;\n\t\t\t\t\t\tq.push({j, col[j]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n
bpm=vector<int> bpm(vector<vector<int>> &G,int n,int m){\n\tconst int MAX = G.size() + 1,NIL = 0,INF = (1 << 28);\n\tvector<int> match(MAX); // Return this if matching is required\n\tvector<int> dist(MAX);\n\tfunction<bool()> bfs = [&]() {\n\t\tqueue<int> Q;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif(match[i] == NIL) {\n\t\t\t\tdist[i] = 0;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t\telse dist[i] = INF;\n\t\t}\n\t\tdist[NIL] = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tint u = Q.front();Q.pop();\n\t\t\tif(u != NIL) {\n\t\t\t\tfor(int v : G[u]){\n\t\t\t\t\tif(dist[match[v]] == INF) {\n\t\t\t\t\t\tdist[match[v]] = dist[u] + 1;\n\t\t\t\t\t\tQ.push(match[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dist[NIL]!=INF);\n\t};\n\tfunction<bool(int)> dfs = [&](int u) {\n\t\tif(u != NIL) {\n\t\t\tfor(int v : G[u]){\n\t\t\t\tif(dist[match[v]] == dist[u]+1) {\n\t\t\t\t\tif(dfs(match[v])){\n\t\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\t\tmatch[u] = v;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdist[u] = INF;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\tint matching = 0;\n\t// match[i] is assumed 0 for all vertex in G\n\twhile(bfs())\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(match[i] == NIL && dfs(i)){\n\t\t\t\tmatching++;\n\t\t\t}\n\t\t}\n\treturn match;\n}\n\n// n = number of applicants \n// m = number of jobs\n// Applicants are enumerated as [1,2,3,...,n]\n// Jobs are enumerated as [n+1,n+2,n+3,...,n+m]\n// Make a double sided edge between applicant and job\n\n// !!! REMEMBER 1-BASED INDEXING !!!\n
mst=struct dsu{\n\tint n;\n\tvector<int> parent;\n\tvector<int> siz;\n\tdsu(int sz) : n(sz){\n\t\tparent.resize(n);\n\t\tsiz.resize(n,1);\n\t\tiota(parent.begin(),parent.end(), 0);\n\t}\n\tbool cmp(int a, int b){ // Give indices here\n\t\treturn siz[a] < siz[b];\n\t}\n\tinline int find(int x){ // Give index here\n\t\treturn (x == parent[x] ? x : (parent[x] = find(parent[x])));\n\t}\n\tinline bool combine(int a, int b){ // Give indices here, (returns true if a and b are in different sets)\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a != b){\n\t\t\tif(cmp(a,b))swap(a,b);\n\t\t\tparent[b] = a;\n\t\t\tsiz[a] += siz[b];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nvector<vector<pair<int,int>>> mst(vector<vector<pair<int,int>>> &adj){ // Undirected minimum spanning tree of undirected graph\n\tint n = adj.size();\n\tvector<vector<int>> edg;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(auto x : adj[i]){\n\t\t\tedg.push_back({x.second,i,x.first});\n\t\t}\n\t}\n\tsort(edg.begin(),edg.end());\n\tdsu uf(n);\n\tvector<vector<pair<int,int>>> ret(n);\n\tfor(auto p : edg){\n\t\tif(uf.combine(p[1],p[2])){\n\t\t\tret[p[1]].push_back({p[2],p[0]});\n\t\t\tret[p[2]].push_back({p[1],p[0]});\n\t\t}\n\t}\n\treturn ret;\n}\n
kmp=bool sub(string pat, string txt){\n\tint M = pat.size();\n\tint N = txt.size();\n\tint lps[M];\n\tauto compute = [&](){\n\t\tint len = 0;\n\t\tlps[0] = 0;\n\t\tint i = 1;\n\t\twhile (i < M){\n\t\t\tif (pat[i] == pat[len]) {\n\t\t\t\tlen++;\n\t\t\t\tlps[i] = len;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (len != 0){\n\t\t\t\t\tlen = lps[len - 1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlps[i] = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tcompute();\n\tint i = 0,j = 0;\n\twhile (i < N) {\n\t\tif (pat[j] == txt[i]){\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\tif (j == M){\n\t\t\t//Found pattern at index (i - j)\n\t\t\treturn true;\n\t\t\tj = lps[j - 1];\n\t\t}\n\t\telse if (i < N && pat[j] != txt[i]) {\n\t\t\tif (j != 0)j = lps[j - 1];\n\t\t\telse i = i + 1;\n\t\t}\n\t}\n\treturn false;\n}\n
sieve=vector<bool> prime;\nvoid sieve(int n_n = 1000000){\n\tprime.resize(n_n+5,true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i*i <= n_n; i++){\n\t\tif(!prime[i])continue;\n\t\tfor(int j = 2; i*j <= n_n; j++){\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n}\n
factor=vector<int> smallest_factor;\nvector<bool> prime;\nvector<int> primes;\nvoid prep(int maximum = 1e6) {\n\tmaximum = max(maximum, 1);\n\tsmallest_factor.assign(maximum + 1, 0);\n\tprime.assign(maximum + 1, true);\n\tprime[0] = prime[1] = false;\n\tprimes = {};\n\tfor(int p = 2; p <= maximum; p++){\n\t\tif(prime[p]) {\n\t\t\tsmallest_factor[p] = p;\n\t\t\tprimes.push_back(p);\n\t\t\tfor(ll i = (ll)(p) * p; i <= maximum; i += p){\n\t\t\t\tif (prime[i]) {\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t\tsmallest_factor[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// Prime factorizes n in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).\n// If we've run `sieve` up to at least n, takes O(log n) time.\nvector<pair<ll, int>> prime_factorize(ll n){ // Prime,exponent\n\tll sieve_max = (ll)(smallest_factor.size()) - 1;\n\tassert(1 <= n && n <= sieve_max * sieve_max);\n\tvector<pair<ll, int>> result;\n\tif(n <= sieve_max){\n\t\twhile(n != 1){\n\t\t\tll p = smallest_factor[n];\n\t\t\tint exponent = 0;\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\texponent++;\n\t\t\t} while (n % p == 0);\n\t\t\tresult.emplace_back(p, exponent);\n\t\t}\n\t\treturn result;\n\t}\n\tfor(ll p : primes){\n\t\tif(p * p > n)\n\t\t\tbreak;\n\t\tif(n % p == 0){\n\t\t\tresult.emplace_back(p, 0);\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\tresult.back().second++;\n\t\t\t} while (n % p == 0);\n\t\t}\n\t}\n\tif(n > 1)\n\t\tresult.emplace_back(n, 1);\n\treturn result;\n}\n
fft=const int mod = 998244353;\n\nstruct base {\n\tdouble x, y;\n\tbase(){\n\t\tx = y = 0;\n\t}\n\tbase(double a, double b){\n\t\tx = a;\n\t\ty = b;\n\t}\n};\ninline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }\ninline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }\ninline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline base conj(base a) { return base(a.x, -a.y); }\nint lim = 1;\nvector<base> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\nconst double PI = acosl(- 1.0);\nvoid ensure_base(int p){\n\tif(p <= lim) return;\n\trev.resize(1 << p);\n\tfor(int i = 0; i < (1 << p); i++)\n\t\trev[i] = (rev[i >> 1] >> 1) + ((i & 1)  <<  (p - 1));\n\troots.resize(1 << p);\n\twhile(lim < p) {\n\t\tdouble angle = 2 * PI / (1 << (lim + 1));\n\t\tfor(int i = 1 << (lim - 1); i < (1 << lim); i++){\n\t\t\troots[i << 1] = roots[i];\n\t\t\tdouble angle_i = angle * (2 * i + 1 - (1 << lim));\n\t\t\troots[(i << 1) + 1] = base(cos(angle_i), sin(angle_i));\n\t\t}\n\t\tlim++;\n\t}\n}\nvoid fft(vector<base> &a, int n = -1) {\n\tif(n == -1) n = a.size();\n\tassert((n & (n - 1)) == 0);\n\tint zeros = __builtin_ctz(n);\n\tensure_base(zeros);\n\tint shift = lim - zeros;\n\tfor(int i = 0; i < n; i++)if(i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\n\tfor(int k = 1; k < n; k <<= 1) {\n\t\tfor(int i = 0; i < n; i += 2 * k) {\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tbase z = a[i + j + k] * roots[j + k];\n\t\t\t\ta[i + j + k] = a[i + j] - z;a[i + j] = a[i + j] + z;\n\t\t\t}\n\t\t}\n\t}\n}\nvector<int> multiply(vector<int> &a, vector<int> &b, bool eq = 0){\n\tint need = a.size() + b.size() - 1;\n\tint p = 0;\n\twhile((1 << p) < need)p++;\n\tensure_base(p);\n\tint sz = 1 << p;\n\tvector<base> A, B;\n\tif(sz > (int)A.size()) A.resize(sz);\n\tfor(int i = 0; i < (int)a.size(); i++){\n\t\tint x = (a[i] % mod + mod) % mod;\n\t\tA[i] = base(x & ((1 << 15) - 1), x >> 15);\n\t}\n\tfill(A.begin() + a.size(), A.begin() + sz, base{0, 0});\n\tfft(A, sz);\n\tif(sz > (int)B.size()) B.resize(sz);\n\tif(eq) copy(A.begin(), A.begin() + sz, B.begin());\n\t\telse{\n\tfor(int i = 0; i < (int)b.size(); i++){\n\t\t\tint x = (b[i] % mod + mod) % mod;\n\t\t\tB[i] = base(x & ((1 << 15) - 1), x >> 15);\n\t\t}\n\t\tfill(B.begin() + b.size(), B.begin() + sz, base{0, 0});\n\t\tfft(B, sz);\n\t}\n\tdouble ratio = 0.25 / sz;\n\tbase r2(0,  - 1), r3(ratio, 0), r4(0,  - ratio), r5(0, 1);\n\tfor(int i = 0; i <= (sz >> 1); i++) {\n\t\tint j = (sz - i) & (sz - 1);\n\t\tbase a1 = (A[i] + conj(A[j])), a2 = (A[i] - conj(A[j])) * r2;\n\t\tbase b1 = (B[i] + conj(B[j])) * r3, b2 = (B[i] - conj(B[j])) * r4;\n\t\tif(i != j) {\n\t\t\tbase c1 = (A[j] + conj(A[i])), c2 = (A[j] - conj(A[i])) * r2;\n\t\t\tbase d1 = (B[j] + conj(B[i])) * r3, d2 = (B[j] - conj(B[i])) * r4;\n\t\t\tA[i] = c1 * d1 + c2 * d2 * r5;\n\t\t\tB[i] = c1 * d2 + c2 * d1;\n\t\t}\n\t\tA[j] = a1 * b1 + a2 * b2 * r5;\n\t\tB[j] = a1 * b2 + a2 * b1;\n\t}\n\tfft(A, sz); fft(B, sz);\n\tvector<int> res(need);\n\tfor(int i = 0; i < need; i++){\n\t\tlong long aa = A[i].x + 0.5;\n\t\tlong long bb = B[i].x + 0.5;\n\t\tlong long cc = A[i].y + 0.5;\n\t\tres[i] = (aa + ((bb % mod) << 15) + ((cc % mod) << 30))%mod;\n\t}\n\treturn res;\n}\n
ntt=template <typename T>\nclass NTT {\n public:\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tstatic Type md;\n\tstatic Modular<T> root;\n\tstatic int base;\n\tstatic int max_base;\n\tstatic vector<Modular<T>> roots;\n\tstatic vector<int> rev;\n\tstatic void clear() {\n\t\troot = 0;\n\t\tbase = 0;\n\t\tmax_base = 0;\n\t\troots.clear();\n\t\trev.clear();\n\t}\n\tstatic void init() {\n\t\tmd = T::value;\n\t\tassert(md >= 3 && md % 2 == 1);\n\t\tauto tmp = md - 1;\n\t\tmax_base = 0;\n\t\twhile (tmp % 2 == 0) {\n\t\t\ttmp /= 2;\n\t\t\tmax_base++;\n\t\t}\n\t\troot = 2;\n\t\twhile (power(root, (md - 1) >> 1) == 1) {\n\t\t\troot++;\n\t\t}\n\t\tassert(power(root, md - 1) == 1);\n\t\troot = power(root, (md - 1) >> max_base);\n\t\tbase = 1;\n\t\trev = {0, 1};\n\t\troots = {0, 1};\n\t}\n\tstatic void ensure_base(int nbase) {\n\t\tif (md != T::value) {\n\t\t\tclear();\n\t\t}\n\t\tif (roots.empty()) {\n\t\t\tinit();\n\t\t}\n\t\tif (nbase <= base) {\n\t\t\treturn;\n\t\t}\n\t\tassert(nbase <= max_base);\n\t\trev.resize(1 << nbase);\n\t\tfor (int i = 0; i < (1 << nbase); i++) {\n\t\t\trev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n\t\t}\n\t\troots.resize(1 << nbase);\n\t\twhile (base < nbase) {\n\t\t\tModular<T> z = power(root, 1 << (max_base - 1 - base));\n\t\t\tfor (int i = 1 << (base - 1); i < (1 << base); i++) {\n\t\t\t\troots[i << 1] = roots[i];\n\t\t\t\troots[(i << 1) + 1] = roots[i] * z;\n\t\t\t}\n\t\t\tbase++;\n\t\t}\n\t}\n\tstatic void fft(vector<Modular<T>> &a) {\n\t\tint n = (int) a.size();\n\t\tassert((n & (n - 1)) == 0);\n\t\tint zeros = __builtin_ctz(n);\n\t\tensure_base(zeros);\n\t\tint shift = base - zeros;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif (i < (rev[i] >> shift)) {\n\t\t\t\tswap(a[i], a[rev[i] >> shift]);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1; k < n; k <<= 1) {\n\t\t\tfor (int i = 0; i < n; i += 2 * k) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tModular<T> x = a[i + j];\n\t\t\t\t\tModular<T> y = a[i + j + k] * roots[j + k];\n\t\t\t\t\ta[i + j] = x + y;\n\t\t\t\t\ta[i + j + k] = x - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b) {\n\t\tif(a.empty() || b.empty()) {\n\t\t\treturn {};\n\t\t}\n\t\tint eq = (a == b);\n\t\tint need = (int) a.size() + (int) b.size() - 1;\n\t\tint nbase = 0;\n\t\twhile ((1 << nbase) < need) nbase++;\n\t\tensure_base(nbase);\n\t\tint sz = 1 << nbase;\n\t\ta.resize(sz);\n\t\tb.resize(sz);\n\t\tfft(a);\n\t\tif (eq) b = a; else fft(b);\n\t\tModular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);\n\t\tfor (int i = 0; i < sz; i++) {\n\t\t\ta[i] *= b[i] * inv_sz;\n\t\t}\n\t\treverse(a.begin() + 1, a.end());\n\t\tfft(a);\n\t\ta.resize(need);\n\t\treturn a;\n\t}\n};\ntemplate <typename T> typename NTT<T>::Type NTT<T>::md;\ntemplate <typename T> Modular<T> NTT<T>::root;\ntemplate <typename T> int NTT<T>::base;\ntemplate <typename T> int NTT<T>::max_base;\ntemplate <typename T> vector<Modular<T>> NTT<T>::roots;\ntemplate <typename T> vector<int> NTT<T>::rev;\ntemplate <typename T>\nvector<Modular<T>> inverse(const vector<Modular<T>>& a) {\n\tassert(!a.empty());\n\tint n = (int) a.size();\n\tvector<Modular<T>> b = {1 / a[0]};\n\twhile((int) b.size() < n){\n\t\tvector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n\t\tx.resize(b.size() << 1);\n\t\tb.resize(b.size() << 1);\n\t\tvector<Modular<T>> c = b;\n\t\tNTT<T>::fft(c);\n\t\tNTT<T>::fft(x);\n\t\tModular<T> inv = 1 / static_cast<Modular<T>>((int) x.size());\n\t\tfor(int i = 0; i < (int) x.size(); i++){\n\t\t\tx[i] *= c[i] * inv;\n\t\t}\n\t\treverse(x.begin() + 1, x.end());\n\t\tNTT<T>::fft(x);\n\t\trotate(x.begin(), x.begin() + (x.size() >> 1), x.end());\n\t\tfill(x.begin() + (x.size() >> 1), x.end(), 0);\n\t\tNTT<T>::fft(x);\n\t\tfor(int i = 0; i < (int) x.size(); i++){\n\t\t\tx[i] *= c[i] * inv;\n\t\t}\n\t\treverse(x.begin() + 1, x.end());\n\t\tNTT<T>::fft(x);\n\t\tfor(int i = 0; i < ((int) x.size() >> 1); i++){\n\t\t\tb[i + ((int) x.size() >> 1)] = -x[i];\n\t\t}\n\t}\n\tb.resize(n);\n\treturn b;\n}\ntemplate <typename T>\nvector<Modular<T>> inverse_old(vector<Modular<T>> a) {\n\tassert(!a.empty());\n\tint n = (int) a.size();\n\tif(n == 1){\n\t\treturn {1 / a[0]};\n\t}\n\tint m = (n + 1) >> 1;\n\tvector<Modular<T>> b = inverse(vector<Modular<T>>(a.begin(), a.begin() + m));\n\tint need = n << 1;\n\tint nbase = 0;\n\twhile((1 << nbase) < need) {\n\t\t++nbase;\n\t}\n\tNTT<T>::ensure_base(nbase);\n\tint size = 1 << nbase;\n\ta.resize(size);\n\tb.resize(size);\n\tNTT<T>::fft(a);\n\tNTT<T>::fft(b);\n\tModular<T> inv = 1 / static_cast<Modular<T>>(size);\n\tfor(int i = 0; i < size; ++i){\n\t\ta[i] = (2 - a[i] * b[i]) * b[i] * inv;\n\t}\n\treverse(a.begin() + 1, a.end());\n\tNTT<T>::fft(a);\n\ta.resize(n);\n\treturn a;\n}\ntemplate <typename T>\nvector<Modular<T>> operator*(const vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n\tif(a.empty() || b.empty()){\n\t\treturn {};\n\t}\n\tif(min(a.size(), b.size()) < 150){\n\t\tvector<Modular<T>> c(a.size() + b.size() - 1, 0);\n\t\tfor (int i = 0; i < (int) a.size(); i++) {\n\t\t\tfor (int j = 0; j < (int) b.size(); j++){\n\t\t\t\tc[i + j] += a[i] * b[j];\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\treturn NTT<T>::multiply(a, b);\n}\ntemplate <typename T>\nvector<Modular<T>>& operator*=(vector<Modular<T>>& a, const vector<Modular<T>>& b) {\n\treturn a = a * b;\n}\n// Needs Modular\n
traverse=vector<int> Enter,Exit,order;\nvoid traverse(vector<vector<int>> &adj,int root = 0){\n\tint V = adj.size();\n\torder.clear();\n\tEnter.clear();Enter.resize(V);\n\tExit.clear();Exit.resize(V);\n\tint travel_time = 0;\n\tfunction<void(int,int)> traverse_tree = [&](int i, int parent){\n\t\torder.push_back(i);\n\t\tEnter[i] = travel_time++;\n\t\tfor(int node : adj[i]){\n\t\t\tif(node != parent){\n\t\t\t\ttraverse_tree(node,i);\n\t\t\t}\n\t\t}\n\t\tExit[i] = travel_time++;\n\t};traverse_tree(root,-1);\n}\n\nbool anc(int child, int ancestor){ // If ansector is an ancestor of child\n\treturn Enter[ancestor] < Enter[child] && Exit[child] < Exit[ancestor];\n}\n
scc=vector<vector<int>> scc;\nvector<int> comp;\n\nvoid SCC(vector<vector<int>> &adj){\n\tscc.clear();comp.clear();\n\tint V = adj.size();\n\tcomp.resize(V);\n\tint *disc = new int[V];\n\tint *low = new int[V];\n\tbool *stackMember = new bool[V];\n\tstack<int> *st = new stack<int>();\n\tfor (int i = 0; i < V; i++){\n\t\tdisc[i] = -1;\n\t\tlow[i] = -1;\n\t\tstackMember[i] = false;\n\t}\n\tstatic int time = 0;\n\tfunction<void(int)> find_scc = [&](int u){\n\t\tdisc[u] = low[u] = ++time;\n\t\tst->push(u);\n\t\tstackMember[u] = true;\n\t\tfor (auto i = adj[u].begin(); i != adj[u].end(); ++i){\n\t\t\tint v = *i;\n\t\t\tif (disc[v] == -1){\n\t\t\t\tfind_scc(v);\n\t\t\t\tlow[u]  = min(low[u], low[v]);\n\t\t\t}\n\t\t\telse if (stackMember[v])\n\t\t\t\tlow[u]  = min(low[u], disc[v]);\n\t\t}\n\t\tint w = 0;\n\t\tif (low[u] == disc[u]){\n\t\t\tvector<int> row;\n\t\t\tint ID = scc.size();\n\t\t\twhile (st->top() != u){\n\t\t\t\tw = (int) st->top();\n\t\t\t\trow.push_back(w);\n\t\t\t\tcomp[w] = ID;\n\t\t\t\tstackMember[w] = false;\n\t\t\t\tst->pop();\n\t\t\t}\n\t\t\tw = (int) st->top();\n\t\t\trow.push_back(w);\n\t\t\tcomp[w] = ID;\n\t\t\tscc.push_back(row);\n\t\t\tstackMember[w] = false;\n\t\t\tst->pop();\n\t\t}\n\t};\n\tfor (int i = 0; i < V; i++){\n\t\tif (disc[i] == -1)find_scc(i);\n\t}\n}\n
toposort=vector<int> toposort(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tstack<int> Stack;\n\tvector<bool> visited(V,false);\n\tfunction<void(int)> toposort = [&](int v) -> void {\n\t\tvisited[v] = true;\n\t\tfor(auto i : adj[v])\n\t\t\tif(!visited[i])\n\t\t\t\ttoposort(i);\n\t\tStack.push(v);\n\t};\n\tfor(int i = 0; i < V; i++)\n\t\tif (!visited[i])\n\t\t\ttoposort(i);\n\tvector<int> ans;\n\twhile(!Stack.empty()) {\n\t\tans.push_back(Stack.top());\n\t\tStack.pop();\n\t}\n\treturn ans;\n}\n
cycleu=//This detects cycle in an ***undirected graph***\nvector<int> cyc;\nbool isCyclic(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tbool *visited = new bool[V];\n\tfor(int i = 0; i < V; i++){\n\t\tvisited[i] = false;\n\t}\n\tfunction<bool(int,int)> cycle = [&](int v,int parent) -> bool {\n\t\tcyc.push_back(v);\n\t\tvisited[v] = true;\n\t\tfor(int i : adj[v]){\n\t\t\tif (!visited[i]){\n\t\t\t\tif(cycle(i,v)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i != parent){\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\twhile(!cyc.empty() && cyc.back() != i)cyc.pop_back();\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcyc.pop_back();\n\t\treturn false;\n\t};\n\tfor(int i = 0; i < V; i++){\n\t\tif(!visited[i] && cycle(i,-1)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n
cycled=//This detects cycle in a ***directed graph***\nbool isCyclic(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tbool *visited = new bool[V];\n\tbool *recStack = new bool[V];\n\tfor(int i = 0; i < V; i++){\n\t\tvisited[i] = false;\n\t\trecStack[i] = false;\n\t}\n\tfunction<bool(int)> cycle = [&](int v){\n\t\t\tif(visited[v] == false){\n\t\t\t\tvisited[v] = true;\n\t\t\t\trecStack[v] = true;\n\t\t\t\tfor(int i : adj[v]){\n\t\t\t\t\tif (!visited[i] && cycle(i))return true;\n\t\t\t\t\telse if (recStack[i])return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trecStack[v] = false;\n\t\t\treturn false;\n\t};\n\tfor(int i = 0; i < V; i++){\n\t\tif(cycle(i))return true;\n\t}\n\treturn false;\n}\n
power=ll power(ll x, ll y){\n\tll res = 1;\n\tx = x % mod;\n\tif (x == 0) return 0;\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\n
ncr=const int MXN = %cursor%;\nconst ll mod = %cursor%;\nll fac[MXN],invfac[MXN];\nll power(ll x, ll y){\n\tll res = 1;\n\tx = x % mod;\n\tif (x == 0) return 0;\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\nvoid prep(){ // Don't forget to call this\n\tfac[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfac[i] = fac[i-1]*i;\n\t\tfac[i] %= mod;\n\t}\n\tinvfac[MXN-1] = power(fac[MXN-1],mod-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinvfac[i] = invfac[i+1]*(i+1);\n\t\tinvfac[i] %= mod;\n\t}\n}\nll C(int n,int r){\n\tif(n < r)return 0;\n\treturn ((fac[n]*invfac[r])%mod * invfac[n-r])%mod;\n}\n
zfun=vector<int> z_function(string s) {\n\tint n = (int) s.length();\n\tvector<int> z(n);\n\tfor (int i = 1, l = 0, r = 0; i < n; ++i) {\n\t\tif (i <= r)\n\t\t\tz[i] = min (r - i + 1, z[i - l]);\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]])\n\t\t\t++z[i];\n\t\tif (i + z[i] - 1 > r)\n\t\t\tl = i, r = i + z[i] - 1;\n\t}\n\treturn z;\n}\n
suffix=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n
lcp=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n\n \nvector<int> lcp(string txt){\n\tint n = txt.size();\n\tvector<int> lcp(n, 0);\n\tvector<int> invSuff(n, 0);\n\tvector<int> suffixArr = suffix_array(txt);\n\tfor(int i = 0; i < n; i++)\n\t\tinvSuff[suffixArr[i]] = i;\n\tint k = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (invSuff[i] == n-1){\n\t\t\tk = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = suffixArr[invSuff[i]+1];\n\t\twhile (i+k<n && j+k<n && txt[i+k]==txt[j+k])\n\t\t\tk++;\n\t\tlcp[invSuff[i]] = k;\n\t\tk -= k > 0;\n\t}\n\treturn lcp;\n}\n

# One line shorthands
f=first
s=second
b=begin()
e=end()
be=%cursor%.begin(),%cursor%.end()
find=find(%cursor%) != %cursor%.end()
nfind=find(%cursor%) == %cursor%.end()
re=resize(%cursor%);
pb=push_back
mp=make_pair
ppb=pop_back()
sort=sort(%cursor%.begin(),%cursor%.end());
rsort=sort(%cursor%.rbegin(),%cursor%.rend());
sortcst=sort(%cursor%.begin(),%cursor%.end(),[&](const auto &v1,const auto &v2){\n\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n});\n
reverse=reverse(%cursor%.begin(),%cursor%.end());
iota=iota(%cursor%.begin(),%cursor%.end(),%cursor%);
unique=%cursor%.erase(unique(%cursor%.begin(), %cursor%.end()), %cursor%.end()); // Vector MUST be sorted
lb=lower_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value >= val\n
ub=upper_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value > val\n
dxdy=vector<int> dx = {-1,1,0,0};\nvector<int> dy = {0,0,1,-1};\n
fast=ios::sync_with_stdio(false);cin.tie(0);
skl=#ifdef shivang_ka_laptop\n\t%cursor%\n#endif\n
uskl=#undef shivang_ka_laptop\n
todo=#pragma message("%cursor%")

[Kotlin]
test=import java.lang.AssertionError\n\nprivate fun readLn() = readLine()!! // string line\nprivate fun readInt() = readLn().toInt() // single int\nprivate fun readLong() = readLn().toLong() // single long\nprivate fun readDouble() = readLn().toDouble() // single double\nprivate fun readStrings() = readLn().split(" ") // list of strings\nprivate fun readInts() = readStrings().map { it.toInt() } // list of ints\nprivate fun readLongs() = readStrings().map { it.toLong() } // list of longs\nprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles\n\nprivate fun myAssert(x: Boolean) {\n    if (!x) {\n        throw AssertionError()\n    }\n}\n\nfun testcase(){\n\t%cursor%\n}\n\nfun main() {\n\tvar tt = readInt()\n    for (qq in 0 until tt) {\n        testcase()\n    }\n}\n
vi=var %cursor%: MutableList<Int> = mutableListOf<Int>()
vs=var %cursor%: MutableList<String> = mutableListOf<String>()
for=for(i in 0 .. %cursor%-1){\n\t\n}\n
#[C]

#[Java]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (int i = 0; i < %cursor%; i++)%brace_open%\n%brace_close%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%
#{=%\n{\n\t%cursor%\n}%
#[PHP]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for ($i = 0; $i < %cursor%; $i++)%brace_open%\n%brace_close%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[Javascript]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[C#]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[Vala]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[ActionScript]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

[Python]
for=for i in range(%cursor%):\n\t
forj=for j in range(%cursor%):\n\t
fork=for k in range(%cursor%):\n\t
#if=if %cursor%:\n\t
#elif=elif %cursor%:\n\t
#else=else:\n\t
#while=while %cursor%:\n\t
#try=try:\n\t%cursor%\nexcept Exception, ex:\n\t
#with=with %cursor%:\n\t
#def=def %cursor% (%cursor%):\n\t""" Function doc """\n\t
#class=class %cursor%:\n\t""" Class doc """\n\t\n\tdef __init__ (self):\n\t\t""" Class initialiser """\n\t\tpass

#[Ferite]
#iferr=iferr%block_cursor%fix%block%
#monitor=monitor%block_cursor%handle%block%

#[Haskell]

#[HTML]
#table=<table>\n\t<tr>\n\t\t<td>%cursor%</td>\n\t</tr>\n</table>

#[Erlang]
#case=case %cursor% of\n\t%cursor% -> %cursor%\nend
#if=if\n\t%cursor% -> %cursor%\nend
#begin=begin\n\t%cursor%\nend
#fun=fun(%cursor%) ->\n\t%cursor%\nend
#try=try %cursor% of\n\t%cursor% ->\n\t%cursor%\ncatch\n\t%cursor% ->\n\t%cursor%\nend
#module=-module(%cursor%).
#export=-export(%cursor%).
#compile=-compile(%cursor%).
#include=-include(%cursor%).
