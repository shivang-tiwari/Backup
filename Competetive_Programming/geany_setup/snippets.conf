# Geany's snippets configuration file for Shivang Tiwari

# use \n or %newline% for a new line (it will be replaced by the used EOL char(s) - LF, CR/LF, CR).
# use \t or %ws% for an indentation step, it will be replaced according to the current document's indent mode.
# use \s to force whitespace at beginning or end of a value ('key= value' won't work, use 'key=\svalue').
# use %key% for all keys defined in the [Special] section.
# use %cursor% to define where the cursor should be placed after completion. You can define multiple
#     %cursor% wildcards and use the "Move cursor in snippet" to jump to the next defined cursor
#     position in the completed snippet.
# You can define a section for each supported filetype to overwrite default settings, the section
# name must match exactly the internal filetype name, run 'geany --ft-names' for a full list.

# Additionally, you can use most of the template wildcards like {developer}, {command:...},
# or {date} in the snippets.
# See the documentation for details.

# For a list of available filetype names, execute:
# geany --ft-names

# Default is used for all filetypes and keys can be overwritten by [filetype] sections
[Default]

# special keys to be used in other snippets, cannot be used "standalone"
# can be used by %key%, e.g. %brace_open%
# nesting of special keys is not supported (e.g. brace_open=\n{\n%brace_close% won't work)
# key "wordchars" is very special, it defines the word delimiting characters when looking for
# a word to auto complete, leave commented to use the default wordchars
[Special]
#brace_open=\n{\n\t
#brace_close=}\n
#block=\n{\n\t%cursor%\n}
block_cursor={\n\t\n}
#wordchars=_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789

# Optional keybindings to insert snippets
# Note: these can be overridden by Geany's configurable keybindings
#[Keybindings]
#for=<Ctrl>7


[C++]
# Templates
test=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 42;\n#endif\n#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T> void operator+=(vector<T>& vec, const T value) { for(T &x : vec)x += value; }\ntemplate <typename T> void operator-=(vector<T>& vec, const T value) { for(T &x : vec)x -= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,T) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,T) { vec -= 1; }\ntemplate <typename T> void operator*=(vector<T>& vec, const T value) { for(T &x : vec)x *= value; }\ntemplate <typename T> void operator/=(vector<T>& vec, const T value) { for(T &x : vec)x /= value; }\ntemplate <typename T,typename U> void operator+=(pair<T,U>& vec, const T value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U> void operator-=(pair<T,U>& vec, const T value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,T) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,T) { vec -= 1; } \ntemplate <typename T,typename U> void operator*=(pair<T,U>& vec, const T value) { vec.first *= value;vec.second *= value; } \ntemplate <typename T,typename U> void operator/=(pair<T,U>& vec, const T value) { vec.first /= value;vec.second /= value; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
notest=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 42;\n#endif\n#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T> void operator+=(vector<T>& vec, const T value) { for(T &x : vec)x += value; }\ntemplate <typename T> void operator-=(vector<T>& vec, const T value) { for(T &x : vec)x -= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,T) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,T) { vec -= 1; }\ntemplate <typename T> void operator*=(vector<T>& vec, const T value) { for(T &x : vec)x *= value; }\ntemplate <typename T> void operator/=(vector<T>& vec, const T value) { for(T &x : vec)x /= value; }\ntemplate <typename T,typename U> void operator+=(pair<T,U>& vec, const T value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U> void operator-=(pair<T,U>& vec, const T value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,T) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,T) { vec -= 1; } \ntemplate <typename T,typename U> void operator*=(pair<T,U>& vec, const T value) { vec.first *= value;vec.second *= value; } \ntemplate <typename T,typename U> void operator/=(pair<T,U>& vec, const T value) { vec.first /= value;vec.second /= value; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\t//cin >> tt;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
codejam=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 42;\n#endif\n#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T> void operator+=(vector<T>& vec, const T value) { for(T &x : vec)x += value; }\ntemplate <typename T> void operator-=(vector<T>& vec, const T value) { for(T &x : vec)x -= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,T) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,T) { vec -= 1; }\ntemplate <typename T> void operator*=(vector<T>& vec, const T value) { for(T &x : vec)x *= value; }\ntemplate <typename T> void operator/=(vector<T>& vec, const T value) { for(T &x : vec)x /= value; }\ntemplate <typename T,typename U> void operator+=(pair<T,U>& vec, const T value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U> void operator-=(pair<T,U>& vec, const T value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,T) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,T) { vec -= 1; } \ntemplate <typename T,typename U> void operator*=(pair<T,U>& vec, const T value) { vec.first *= value;vec.second *= value; } \ntemplate <typename T,typename U> void operator/=(pair<T,U>& vec, const T value) { vec.first /= value;vec.second /= value; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nvoid testcase(){\n\t%cursor%\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1,casen = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tcout << "Case #" << casen << ": ";\n\t\ttestcase();\n\t\tcasen++;\n\t}\n\treturn (0-0);\n}\n
tester=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define booga cerr << "booga" << endl\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)\n#define safai(...) Clearing_out(__VA_ARGS__)\n\n\ntemplate <typename A, typename B>\n\tstring to_string(pair<A, B> p);\n \ntemplate <typename A, typename B, typename C>\n\tstring to_string(tuple<A, B, C> p);\n \ntemplate <typename A, typename B, typename C, typename D>\n\tstring to_string(tuple<A, B, C, D> p);\n \nstring to_string(const string& s) {\n\treturn '"' + s + '"';\n}\n\nstring to_string(char c) {\n\tstring s;\n\ts += c;\n\treturn s;\n}\n\nstring to_string(const char* s) {\n\treturn to_string((string) s);\n}\n \nstring to_string(bool b) {\n\treturn (b ? "1" : "0");\n}\n \nstring to_string(vector<bool> v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (int i = 0; i < static_cast<int>(v.size()); i++) {\n\tif (!first) {\n\t\tres += ", ";\n\t}\n\tfirst = false;\n\tres += to_string(v[i]);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n\tstring res = "";\n\tfor (size_t i = 0; i < N; i++) {\n\t\tres += static_cast<char>('0' + v[i]);\n\t}\n\treturn res;\n}\n \ntemplate <typename A>\nstring to_string(A v) {\n\tbool first = true;\n\tstring res = "{";\n\tfor (const auto &x : v) {\n\t\tif (!first) {\n\t\t\tres += ", ";\n\t\t}\n\t\tfirst = false;\n\t\tres += to_string(x);\n\t}\n\tres += "}";\n\treturn res;\n}\n \ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n\treturn "(" + to_string(p.first) + ", " + to_string(p.second) + ")";\n}\n \ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";\n}\n \ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n\treturn "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";\n}\n \nvoid debug_out() { cerr << endl; }\n \ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tcerr << " " << to_string(H);\n\tdebug_out(T...);\n}\n\nvoid Clearing_out() { return; }\n\ntemplate <typename Head, typename... Tail>\nvoid Clearing_out(Head &H, Tail & ... T) {\n\tH.clear();\n\tClearing_out(T...);\n}\nofstream myfile;\n\nvoid testcase(){\n\t%cursor%\n}\n\n\nint main(){\n\tmyfile.open("test_details.txt");\n\tint tt = 1;\n\tcout << tt << endl;\n\twhile(tt--){\n\t\ttestcase();\n\t}\n\treturn (0-0);\n}\n
solve=// हर हर महादेव\nusing namespace std;\n#include <bits/stdc++.h>\n#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 42;\n#endif\n#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T> void operator+=(vector<T>& vec, const T value) { for(T &x : vec)x += value; }\ntemplate <typename T> void operator-=(vector<T>& vec, const T value) { for(T &x : vec)x -= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,T) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,T) { vec -= 1; }\ntemplate <typename T> void operator*=(vector<T>& vec, const T value) { for(T &x : vec)x *= value; }\ntemplate <typename T> void operator/=(vector<T>& vec, const T value) { for(T &x : vec)x /= value; }\ntemplate <typename T,typename U> void operator+=(pair<T,U>& vec, const T value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U> void operator-=(pair<T,U>& vec, const T value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,T) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,T) { vec -= 1; } \ntemplate <typename T,typename U> void operator*=(pair<T,U>& vec, const T value) { vec.first *= value;vec.second *= value; } \ntemplate <typename T,typename U> void operator/=(pair<T,U>& vec, const T value) { vec.first /= value;vec.second /= value; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n\nclass solution{\n\tpublic:\n\tvoid testcase(){\n\t\t%cursor%\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint tt = 1;\n\tcin >> tt;\n\twhile(tt--){\n\t\tsolution solver;\n\t\tsolver.testcase();\n\t}\n\treturn (0-0);\n}\n
debug=#define ll long long int\n#define ld long double\n#define pb push_back\n#define mp make_pair\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\nmt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n#ifdef shivang_ka_laptop\n\t#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__);\n\t#define booga cerr << "booga" << endl;\n#else\n\t#define debug(...) 42;\n\t#define booga 42;\n#endif\n#pragma GCC optimize("Ofast")\n#pragma GCC target("fma,sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")\n#pragma GCC optimize("unroll-loops")\n\ntemplate <typename T> std::ostream& operator<<(std::ostream& stream, const vector<T>& vec){ for(size_t i = 0; i < vec.size(); i++){stream << vec[i];if(i != vec.size() - 1)stream << ' ';}; return stream; }\ntemplate <typename T> std::istream& operator>>(std::istream& stream, vector<T>& vec) { for(T &x : vec)stream >> x;return stream; }\ntemplate <typename T,typename U> std::ostream& operator<<(std::ostream& stream, const pair<T,U>& pr){ stream << pr.first << ' ' << pr.second; return stream; }\ntemplate <typename T,typename U> std::istream& operator>>(std::istream& stream, pair<T,U>& pr){ stream >> pr.first >> pr.second; return stream; }\ntemplate <typename T> void operator+=(vector<T>& vec, const T value) { for(T &x : vec)x += value; }\ntemplate <typename T> void operator-=(vector<T>& vec, const T value) { for(T &x : vec)x -= value; }\ntemplate <typename T> void operator++(vector<T>& vec) { vec += 1; }\ntemplate <typename T> void operator++(vector<T>& vec,T) { vec += 1; }\ntemplate <typename T> void operator--(vector<T>& vec) { vec -= 1; }\ntemplate <typename T> void operator--(vector<T>& vec,T) { vec -= 1; }\ntemplate <typename T> void operator*=(vector<T>& vec, const T value) { for(T &x : vec)x *= value; }\ntemplate <typename T> void operator/=(vector<T>& vec, const T value) { for(T &x : vec)x /= value; }\ntemplate <typename T,typename U> void operator+=(pair<T,U>& vec, const T value) { vec.first += value;vec.second += value; }\ntemplate <typename T,typename U> void operator-=(pair<T,U>& vec, const T value) { vec.first -= value;vec.second -= value; }\ntemplate <typename T,typename U> void operator++(pair<T,U>& vec) { vec += 1; } \ntemplate <typename T,typename U> void operator++(pair<T,U>& vec,T) { vec += 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec) { vec -= 1; } \ntemplate <typename T,typename U> void operator--(pair<T,U>& vec,T) { vec -= 1; } \ntemplate <typename T,typename U> void operator*=(pair<T,U>& vec, const T value) { vec.first *= value;vec.second *= value; } \ntemplate <typename T,typename U> void operator/=(pair<T,U>& vec, const T value) { vec.first /= value;vec.second /= value; } \n\ntemplate <typename A, typename B>string to_string(pair<A, B> p);\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p);\ntemplate <typename A, typename B, typename C, typename D>string to_string(tuple<A, B, C, D> p);\nstring to_string(const string& s) { return '"' + s + '"'; }\nstring to_string(char c) {string s;s += c;return s; }\nstring to_string(const char* s) {return to_string((string) s); }\nstring to_string(bool b) {return (b ? "1" : "0"); }\nstring to_string(vector<bool> v) {bool first = true;string res = "{";for (int i = 0; i < static_cast<int>(v.size()); i++) {if (!first) {res += ", ";}first = false;res += to_string(v[i]);}res += "}";return res;}\ntemplate <size_t N>string to_string(bitset<N> v) {string res = "";for (size_t i = 0; i < N; i++) {res += static_cast<char>('0' + v[i]);}return res;}\ntemplate <typename A>string to_string(A v) {bool first = true;string res = "{";for (const auto &x : v) {if (!first) {res += ", ";}first = false;res += to_string(x);}res += "}";return res;}\ntemplate <typename A, typename B>string to_string(pair<A, B> p) {return "(" + to_string(p.first) + ", " + to_string(p.second) + ")";}\ntemplate <typename A, typename B, typename C>string to_string(tuple<A, B, C> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ")";}\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {return "(" + to_string(get<0>(p)) + ", " + to_string(get<1>(p)) + ", " + to_string(get<2>(p)) + ", " + to_string(get<3>(p)) + ")";}\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nvoid debug_out() { cerr << endl; } template <typename Head, typename... Tail>void debug_out(Head H, Tail... T) {cerr << " " << to_string(H);debug_out(T...);}\nvoid bharo(int N_N) { return; }template <typename Head, typename... Tail>void bharo(int N_N, Head &H, Tail & ... T) {H.resize(N_N);bharo(N_N,T...);}\nvoid safai() { return; }template <typename Head, typename... Tail>void safai(Head &H, Tail & ... T) {H.clear();safai(T...);}\n
basic=#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\t%cursor%\n\treturn 0;\n}\n
modular=template <typename T>\nT inverse(T a, T m) {\n\tT u = 0, v = 1;\n\twhile (a != 0) {\n\t\tT t = m / a;\n\t\tm -= t * a; swap(a, m);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tassert(m == 1);\n\treturn u;\n}\n \ntemplate <typename T>\nclass Modular {\n public:\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tconstexpr Modular() : value() {}\n\ttemplate <typename U>\n\tModular(const U& x) {\n\t\tvalue = normalize(x);\n\t}\n\ttemplate <typename U>\n\tstatic Type normalize(const U& x) {\n\t\tType v;\n\t\tif (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n\t\telse v = static_cast<Type>(x % mod());\n\t\tif (v < 0) v += mod();\n\t\treturn v;\n\t}\n\tconst Type& operator()() const { return value; }\n\ttemplate <typename U>\n\texplicit operator U() const { return static_cast<U>(value); }\n\tconstexpr static Type mod() { return T::value; }\n\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n\tModular& operator++() { return *this += 1; }\n\tModular& operator--() { return *this -= 1; }\n\tModular operator++(int) { Modular result(*this); *this += 1; return result; }\n\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }\n\tModular operator-() const { return Modular(-value); }\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n\t\tasm(\n\t\t\t"divl %4; "\n\t\t\t: "=a" (d), "=d" (m)\n\t\t\t: "d" (xh), "a" (xl), "r" (mod())\n\t\t);\n\t\tvalue = m;\n#else\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tlong long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n\t\tvalue = normalize(value * rhs.value - q * mod());\n\t\treturn *this;\n\t}\n\ttemplate <typename U = T>\n\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n\t\tvalue = normalize(value * rhs.value);\n\t\treturn *this;\n\t}\n\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\tfriend const Type& abs(const Modular& x) { return x.value; }\n\ttemplate <typename U>\n\tfriend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename U>\n\tfriend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\ttemplate <typename V, typename U>\n\tfriend V& operator>>(V& stream, Modular<U>& number);\n\tprivate: Type value;\n};\n \ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n \ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n\tassert(b >= 0);\n\tModular<T> x = a, res = 1;\n\tU p = b;\n\twhile (p > 0) {\n\t\tif (p & 1) res *= x;\n\t\tx *= x;\n\t\tp >>= 1;\n\t}\n\treturn res;\n}\n \ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n\treturn number() == 0;\n}\n \ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n\treturn to_string(number());\n}\n \n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n\treturn stream << number();\n}\n \n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n\ttypename common_type<typename Modular<T>::Type, long long>::type x;\n\tstream >> x;\n\tnumber.value = Modular<T>::normalize(x);\n\treturn stream;\n}\n \n\n//using ModType = int;\n \n//struct VarMod { static ModType value; };\n//ModType VarMod::value;\n//ModType& md = VarMod::value;\n//using Mint = Modular<VarMod>;\n \nconstexpr int md = (int) 1e9 + 7;\n//constexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n \n/*\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\n\nconst int MXN = ;\n\nvoid prep(){ // Don't forget to call this to use nCr\n\tfact.resize(MXN);\n\tinv_fact.resize(MXN);\n\tfact[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfact[i] = fact[i-1]*i;\n\t}\n\tinv_fact[MXN-1] = power(fact[MXN-1],md-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinv_fact[i] = inv_fact[i+1]*(i+1);\n\t}\n}\n \n\nMint C(int n, int k) {\n\tif (k < 0 || k > n) {\n\t\treturn (0-0);\n\t}\n\twhile ((int) fact.size() < n + 1) {\n\t\tfact.push_back(fact.back() * (int) fact.size());\n\t\tinv_fact.push_back(1 / fact.back());\n\t}\n\treturn fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n*/\n

# Loops and conditionals
if=if(%cursor%)%block_cursor%
else=else{\n\t%cursor%\n}
while=while(%cursor%)%block_cursor%
for=for(int i = 0; i < %cursor%; i++)%block_cursor%
rev=for(int i = %cursor%; i >= 0; i--)%block_cursor%
forj=for(int j = 0; j < %cursor%; j++)%block_cursor%
revj=for(int j = %cursor%; j >= 0; j--)%block_cursor%
fork=for(int k = 0; k < %cursor%; k++)%block_cursor%
revk=for(int k = %cursor%; k >= 0; k--)%block_cursor%

# Data-types
ll=long long int 
ull=unsigned long long int 
str=string 
pii=pair<int,int> 
pll= pair<ll,ll> 
vec=vector<%cursor%>
set=set<%cursor%>
multi=multiset<%cursor%>
pq=priority_queue<%cursor%>
vi=vector<int> 
vll=vector<ll> 
vc=vector<char> 
vb=vector<bool> 
vs=vector<string> 
vpii=vector<pair<int,int>> 
vpll=vector<pair<ll,ll>> 
vvi=vector<vector<int>> 
vvll=vector<vector<ll>> 
vvc=vector<vector<char>> 
mpii=map<int,int> 
mpci=map<char,int> 

# Inputs
array=int n;\ncin >> n;\nvector<int> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
arrayll=int n;\ncin >> n;\nvector<ll> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
array2d=int n,m;\ncin >> n >> m;\nvector<vector<int>> a(n,vector<int>(m));\nfor(int i = 0; i < n; i++){\n\tfor(int j = 0; j < m; j++){\n\t\tcin >> a[i][j];\n\t}\n}\n
bord=int n,m;\ncin >> n >> m;\nvector<string> a(n);\nfor(int i = 0; i < n; i++){\n\tcin >> a[i];\n}\n
graph=int n,m;\ncin >> n >> m;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
graphw=int n,m;\ncin >> n >> m;\nvector<vector<pair<int,int>>> graph(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\t//graph[v].push_back({u,w});\n}\n
graphwg=cin >> n >> m;\ngraph.resize(n);\nfor(int i = 0; i < m; i++){\n\tint u,v,w;\n\tcin >> u >> v >> w;\n\tu--;v--;\n\tgraph[u].push_back({v,w});\n\tgraph[v].push_back({u,w});\n}\n
tree=int n;\ncin >> n;\nvector<vector<int>> graph(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
treeg=cin >> n;\ngraph.resize(n);\nfor(int i = 0; i < n-1; i++){\n\tint u,v;\n\tcin >> u >> v;\n\tu--;v--;\n\tgraph[u].push_back(v);\n\tgraph[v].push_back(u);\n}\n
fileio=#ifdef shivang_ka_laptop\n\tfreopen("in.txt" , "r", stdin);\n\tfreopen("out.txt" ,"w", stdout);\n#endif\n

# Structures
segtree=class segtree {\n public:\n\tstruct node {\n\t\t// don't forget to set default value (used for leaves)\n\t\t// not necessarily neutral element!\n\t\t%cursor%; // Set identity element\n\t\tint add = 0; \n\n\t\tvoid apply(int l, int r, int v) { // Value of a single node (used by build and update)\n\t\t\t%cursor%;\n\t\t\t//sum = v; \n\t\t}\n\t\tvoid push(int l, int r, int v) { // Lazy propogation (used by add)\n\t\t\t//sum += v*(r - l + 1); \n\t\t\t//add += v;\n\t\t}\n\t};\n\tnode unite(const node &a, const node &b) const { // Set combination operation\n\t\tnode res;\n\t\t%cursor%;\n\t\t//res.sum = a.sum + b.sum; \n\t\treturn res;\n\t}\n\tinline void push(int x, int l, int r) {\n\t\t//int y = (l + r) >> 1;\n\t\t//int z = x + ((y - l + 1) << 1);\n\t\t//if (tree[x].add != 0) {\n\t\t\t//tree[x + 1].push(l, y, tree[x].add);\n\t\t\t//tree[z].push(y + 1, r, tree[x].add);\n\t\t\t//tree[x].add = 0;\n\t\t//}\n\t\t\n\t\t// Don't forget to uncomment node.push\n\t}\n\tinline void pull(int x, int z) {\n\t\ttree[x] = unite(tree[x + 1], tree[z]);\n\t}\n\n\tint n;\n\tvector<node> tree;\n\tvoid build(int x, int l, int r) {\n\t\tif (l == r) {\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y);\n\t\tbuild(z, y + 1, r);\n\t\tpull(x, z);\n\t}\n\ttemplate <typename M>\n\tvoid build(int x, int l, int r, const vector<M> &v) {\n\t\tif (l == r) {\n\t\t\ttree[x].apply(l, r, v[l]);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tbuild(x + 1, l, y, v);\n\t\tbuild(z, y + 1, r, v);\n\t\tpull(x, z);\n\t}\n\tnode find(int x, int l, int r, int lx, int rx) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\treturn tree[x];\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tnode res{};\n\t\tif (rx <= y) {\n\t\t\tres = find(x + 1, l, y, lx, rx);\n\t\t} else {\n\t\t\tif (lx > y) {\n\t\t\tres = find(z, y + 1, r, lx, rx);\n\t\t\t} else {\n\t\t\tres = unite(find(x + 1, l, y, lx, rx), find(z, y + 1, r, lx, rx));\n\t\t\t}\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\ttemplate <typename... M>\n\tvoid update(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].apply(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tupdate(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tupdate(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int x, int l, int r, int lx, int rx, const M&... v) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\ttree[x].push(l, r, v...);\n\t\t\treturn;\n\t\t}\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tpush(x, l, r);\n\t\tif (lx <= y) {\n\t\t\tadd(x + 1, l, y, lx, rx, v...);\n\t\t}\n\t\tif (rx > y) {\n\t\t\tadd(z, y + 1, r, lx, rx, v...);\n\t\t}\n\t\tpull(x, z);\n\t}\n\tint find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n\t\tif (l == r) {\n\t\t\treturn l;\n\t\t}\n\t\tpush(x, l, r);\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tint res;\n\t\tif (f(tree[x + 1])) {\n\t\t\tres = find_first_knowingly(x + 1, l, y, f);\n\t\t}\n\t\telse {\n\t\t\tres = find_first_knowingly(z, y + 1, r, f);\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\tint find_first(int x, int l, int r, int lx, int rx, const function<bool(const node&)> &f) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\tif (!f(tree[x]))return -1;\n\t\t\treturn find_first_knowingly(x, l, r, f);\n\t\t}\n\t\tpush(x, l, r);\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tint res = -1;\n\t\tif (lx <= y) {\n\t\t\tres = find_first(x + 1, l, y, lx, rx, f);\n\t\t}\n\t\tif (rx > y && res == -1) {\n\t\t\tres = find_first(z, y + 1, r, lx, rx, f);\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\tint find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n\t\tif (l == r)return l;\n\t\tpush(x, l, r);\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tint res;\n\t\tif (f(tree[z]))res = find_last_knowingly(z, y + 1, r, f);\n\t\telse res = find_last_knowingly(x + 1, l, y, f);\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\tint find_last(int x, int l, int r, int lx, int rx, const function<bool(const node&)> &f) {\n\t\tif (lx <= l && r <= rx) {\n\t\t\tif (!f(tree[x]))return -1;\n\t\t\treturn find_last_knowingly(x, l, r, f);\n\t\t}\n\t\tpush(x, l, r);\n\t\tint y = (l + r) >> 1;\n\t\tint z = x + ((y - l + 1) << 1);\n\t\tint res = -1;\n\t\tif (rx > y) {\n\t\t\tres = find_last(z, y + 1, r, lx, rx, f);\n\t\t}\n\t\tif (lx <= y && res == -1) {\n\t\t\tres = find_last(x + 1, l, y, lx, rx, f);\n\t\t}\n\t\tpull(x, z);\n\t\treturn res;\n\t}\n\tsegtree(int _n) : n(_n) {\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1);\n\t}\n\ttemplate <typename M>\n\tsegtree(const vector<M> &v) {\n\t\tn = v.size();\n\t\tassert(n > 0);\n\t\ttree.resize(2 * n - 1);\n\t\tbuild(0, 0, n - 1, v);\n\t}\n\tnode find(int p) { // value at index p\n\t\tassert(0 <= p && p <= n - 1);\n\t\treturn find(0, 0, n - 1, p, p);\n\t}\n\ttemplate <typename... M>\n\tvoid update(int lx, int rx, const M&... v) {\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tupdate(0, 0, n - 1, lx, rx, v...);\n\t}\n\tvoid add(int i, int v){\n\t\tassert(i >= 0 && i < n);\n\t\tadd(i,i,v);\n\t}\n\t// All functions below\n\tvoid update(int i, int v){ // Sets value at index i to v\n\t\tassert(i >= 0 && i < n);\n\t\tupdate(i,i,v);\n\t}\n\ttemplate <typename... M>\n\tvoid add(int lx, int rx, const M&... v) { // adds v to a[lx to rx]\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\tadd(0, 0, n - 1, lx, rx, v...);\n\t}\n\tnode find(int lx, int rx) { // value of lx to rx\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\treturn find(0, 0, n - 1, lx, rx);\n\t}\n\t// find_first and find_last call all FALSE elements\n\t// to the left (right) of the sought position exactly once\n\tint find_first(int lx, int rx, const function<bool(const node&)> &f) {\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\treturn find_first(0, 0, n - 1, lx, rx, f);\n\t}\n\tint find_last(int lx, int rx, const function<bool(const node&)> &f) {\n\t\tassert(0 <= lx && lx <= rx && rx <= n - 1);\n\t\treturn find_last(0, 0, n - 1, lx, rx, f);\n\t}\n};\n
fenwick=template <typename T>\nclass fenwick {\n  public:\n\tvector<T> fenw;\n\tint n;\n\tfenwick(int _n) : n(_n) {\n\t\tfenw.resize(n);\n\t}\n\tvoid add(int x, T v) {\n\t\tassert(x < n && x >= 0);\n\t\twhile (x < n) {\n\t\t\tcombine(fenw[x],v);\n\t\t\tx |= (x + 1);\n\t\t}\n\t}\n\tT find(int x) {\n\t\tassert(x < n && x >= 0);\n\t\tT v{};\n\t\twhile (x >= 0) {\n\t\t\tcombine(v,fenw[x]);\n\t\t\tx = (x & (x + 1)) - 1;\n\t\t}\n\t\treturn v;\n\t}\n\tT find(int l,int r) {\n\t\treturn find(r) - (l == 0 ? 0 : find(l-1));\n\t}\n\tvoid combine(T &v, T val){\n\t\t%cursor%\n\t\t//v += val;\n\t}\n};\n
sparse=template<class T>\nclass sparse{\n\tpublic:\n\tint N, LG;\n\tvector<vector<T>>spt;\n\tvector<int>lg;\n\tsparse(){}\n\tsparse(vector<T> &a){\n\t\tN = a.size();\n\t\tLG = 32 - __builtin_clz(std::max(N - 1, 1));\n\t\tspt.resize(N+1, vector<T>(LG+1,0));\n\t\tlg.resize(N + 5,0);\n\t\tfor(int i = 2;i <= N;i++)\n\t\t\tlg[i] = lg[i/2] + 1;\n\t\tbuild(a);\n\t}\n\tvoid build(vector<T> &a){\n\t\tfor(int i = 0;i < N;i++)\n\t\t\tspt[i][0] = a[i];\n\t\tfor(int j = 1;j <= LG;j++){\n\t\t\tint len = (1 << j), half = (1 << (j-1));\n\t\t\tfor(int i = 0;i + len <= N;i++)\n\t\t\t\tspt[i][j] = combine(spt[i][j-1],spt[i+half][j-1]);\n\t\t}\n\t}\n\tT find(int l, int r){ // For idempotent operations in O(1)\n\t\tassert(l <= r && l >= 0 && r <= N-1);\n\t\tint lgg = lg[r-l+1], len = (1<<lgg);\n\t\treturn combine(spt[l][lgg], spt[r-len+1][lgg]);\n\t}\n\tT query(int L, int R){ // For other operations in O(log n)\n\t\tT answer = 0;\n\t\tfor (int j = LG; j >= 0; j--) {\n\t\t\tif (L + (1 << j) - 1 <= R) {\n\t\t\t\tanswer = combine(answer,spt[L][j]);\n\t\t\t\tL += 1 << j;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\tT combine(T x,T y){\n\t\treturn %cursor%;\n\t}\n};\n
lca=struct LCA {\n\tvector<int> height, euler, first, segtree;\n\tvector<bool> visited;\n\tint n;\n\n\tLCA(vector<vector<int>> &adj, int root = 0) {\n\t\tn = adj.size();\n\t\theight.resize(n);\n\t\tfirst.resize(n);\n\t\teuler.reserve(n * 2);\n\t\tvisited.assign(n, false);\n\t\tdfs(adj, root);\n\t\tint m = euler.size();\n\t\tsegtree.resize(m * 4);\n\t\tbuild(1, 0, m - 1);\n\t}\n\n\tvoid dfs(vector<vector<int>> &adj, int node, int h = 0) {\n\t\tvisited[node] = true;\n\t\theight[node] = h;\n\t\tfirst[node] = euler.size();\n\t\teuler.push_back(node);\n\t\tfor (auto to : adj[node]) {\n\t\t\tif (!visited[to]) {\n\t\t\t\tdfs(adj, to, h + 1);\n\t\t\t\teuler.push_back(node);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid build(int node, int b, int e) {\n\t\tif (b == e) {\n\t\t\tsegtree[node] = euler[b];\n\t\t} else {\n\t\t\tint mid = (b + e) / 2;\n\t\t\tbuild(node << 1, b, mid);\n\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\tint l = segtree[node << 1], r = segtree[node << 1 | 1];\n\t\t\tsegtree[node] = (height[l] < height[r]) ? l : r;\n\t\t}\n\t}\n\n\tint query(int node, int b, int e, int L, int R) {\n\t\tif (b > R || e < L)\n\t\t\treturn -1;\n\t\tif (b >= L && e <= R)\n\t\t\treturn segtree[node];\n\t\tint mid = (b + e) >> 1;\n\n\t\tint left = query(node << 1, b, mid, L, R);\n\t\tint right = query(node << 1 | 1, mid + 1, e, L, R);\n\t\tif (left == -1) return right;\n\t\tif (right == -1) return left;\n\t\treturn height[left] < height[right] ? left : right;\n\t}\n\n\tint lca(int u, int v) {\n\t\tint left = first[u], right = first[v];\n\t\tif (left > right)\n\t\t\tswap(left, right);\n\t\treturn query(1, 0, euler.size() - 1, left, right);\n\t}\n};\n
ordset=#include <bits/extc++.h>\nusing namespace __gnu_pbds;\ntemplate <typename A, typename B = std::less <A>> using ordered_set = tree <A, null_type, B, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename A, typename B, typename C = std::less <A>> using ordered_map = tree <A, B, C, rb_tree_tag, tree_order_statistics_node_update>;\n//order_of_key (k) : Number of items strictly smaller than k\n//find_by_order(k) : K-th element in a set (counting from zero)\n
dsu=struct dsu{\n\tint n;\n\tvector<int> parent;\n\tvector<int> siz;\n\tdsu(int sz) : n(sz){\n\t\tparent.resize(n);\n\t\tsiz.resize(n,1);\n\t\tiota(parent.begin(),parent.end(), 0);\n\t}\n\tbool cmp(int a, int b){ // Give indices here\n\t\treturn siz[a] < siz[b];\n\t}\n\tinline int find(int x){ // Give index here\n\t\treturn (x == parent[x] ? x : (parent[x] = find(parent[x])));\n\t}\n\tinline bool combine(int a, int b){ // Give indices here, (returns true if a and b are in different sets)\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif(a != b){\n\t\t\tif(cmp(a,b))swap(a,b);\n\t\t\tparent[b] = a;\n\t\t\tsiz[a] += siz[b];\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n
cst=template<typename T>\nstruct cst{ // const is important\n\tbool operator()(const T& v1, const T& v2) const {\n\t\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n\t}\n};\n
graphst=template<typename T>\nclass Graph{\n\tpublic:\n\tstruct Edge{\n\t\tint from;\n\t\tint to;\n\t\tT cost;\n\t};\n\tint n;\n\tvector<Edge> edges;\n\tvector<vector<int>> adj;\n\tvector<vector<int>> scc;\n\tvector<int> comp,dist,pre;\n\tGraph(int n_n) : n(n_n){\n\t\tadj.resize(n);\n\t}\n\tint add(int u, int v, T w = 1){\n\t\tassert(0 <= u && u < n && 0 <= v && v < n);\n\t\tint ID = edges.size();\n\t\tadj[u].push_back(ID);\n\t\tedges.push_back({u,v,w});\n\t\treturn ID;\n\t}\n\tvoid dijkstra(int start){\n\t\tdist.clear();pre.clear();\n\t\tdist.resize(n,INT_MAX);\n\t\tpre.resize(n,-1);\n\t\tdist[start] = 0;\n\t\tset<pair<int,int>> pq; // distance,id\n\t\tpq.insert({0,start});\n\t\twhile(!pq.empty()){\n\t\t\tint top = pq.begin()->second;\n\t\t\tpq.erase(pq.begin());\n\t\t\tfor(int ID : adj[top]){\n\t\t\t\tauto node = make_pair(edges[ID].to,edges[ID].cost);\n\t\t\t\tif(dist[node.first] > dist[top] + node.second){\n\t\t\t\t\tdist[node.first] = dist[top] + node.second;\n\t\t\t\t\tpre[node.first] = top;\n\t\t\t\t\tpq.insert({dist[node.first],node.first});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid SCC(){\n\t\tcomp.resize(n);\n\t\tint *disc = new int[n];\n\t\tint *low = new int[n];\n\t\tbool *stackMember = new bool[n];\n\t\tstack<int> *st = new stack<int>();\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tdisc[i] = -1;\n\t\t\tlow[i] = -1;\n\t\t\tstackMember[i] = false;\n\t\t}\n\t\tstatic int time = 0;\n\t\tfunction<void(int)> find_scc = [&](int u){\n\t\t\tdisc[u] = low[u] = ++time;\n\t\t\tst->push(u);\n\t\t\tstackMember[u] = true;\n\t\t\tfor (auto i = adj[u].begin(); i != adj[u].end(); ++i){\n\t\t\t\tint v = edges[*i].to;\n\t\t\t\tif (disc[v] == -1){\n\t\t\t\t\tfind_scc(v);\n\t\t\t\t\tlow[u]  = min(low[u], low[v]);\n\t\t\t\t}\n\t\t\t\telse if (stackMember[v] == true)\n\t\t\t\t\tlow[u]  = min(low[u], disc[v]);\n\t\t\t}\n\t\t\tint w = 0;\n\t\t\tif (low[u] == disc[u]){\n\t\t\t\tvector<int> row;\n\t\t\t\tint ID = scc.size();\n\t\t\t\twhile (st->top() != u){\n\t\t\t\t\tw = (int) st->top();\n\t\t\t\t\trow.push_back(w);\n\t\t\t\t\tcomp[w] = ID;\n\t\t\t\t\tstackMember[w] = false;\n\t\t\t\t\tst->pop();\n\t\t\t\t}\n\t\t\t\tw = (int) st->top();\n\t\t\t\trow.push_back(w);\n\t\t\t\tcomp[w] = ID;\n\t\t\t\tscc.push_back(row);\n\t\t\t\tstackMember[w] = false;\n\t\t\t\tst->pop();\n\t\t\t}\n\t\t};\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (disc[i] == -1)find_scc(i);\n\t\t}\n\t}\n};\n

# Algorithms
dijkstra=int n,m;\nvector<vector<pair<int,int>>> graph; // id,weight\nvector<long long int> dist;\nvector<int> pre;\nvoid dijkstra(int start){\n\tdist.clear();dist.resize(n,1e18);\n\tpre.clear();pre.resize(n,-1);\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> que;\n\tque.push({dist[start] = 0, start});\n\twhile (!que.empty()) {\n\t\tauto top = que.top();\n\t\tque.pop();\n\t\tif (top.first != dist[top.second]) continue;\n\t\tfor(auto node : graph[top.second])\n\t\t\tif(dist[node.first] > top.first + node.second) \n\t\t\t\tque.push({dist[node.first] = top.first + node.second, node.first}), pre[node.first] = top.second;\n\t}\n}\n
bpm=// N is number of applicants \n// and M is number of jobs\n// a_ij is true if ith person wants jth job\nint N,M;\nint bpm(vector<vector<bool>> &bpGraph){\n\tvector<int> matchR(M,-1); // return this if matching is required\n\tfunction<bool(int,bool*)> bpm = [&](int u, bool* seen){\n\t\tfor (int v = 0; v < M; v++){\n\t\t\tif (bpGraph[u][v] && !seen[v]){\n\t\t\t\tseen[v] = true;\n\t\t\t\tif (matchR[v] < 0 || bpm(matchR[v],seen)){\n\t\t\t\t\tmatchR[v] = u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\tint result = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tbool seen[M];\n\t\tmemset(seen, 0, sizeof(seen));\n\t\tresult += (bpm(i, seen));\n\t}\n\treturn result; // Number of applicants which will get a job\n}\n
bpcheck=vector<int> col;\nbool bpcheck(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tcol.resize(V,-1);\n\tqueue<pair<int,int>> q;\n\tfor(int i = 0; i < V; i++){\n\t\tif(col[i] == -1) {\n\t\t\tq.push({i,0});\n\t\t\tcol[i] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tpair<int,int> p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tint v = p.first;\n\t\t\t\tint c = p.second;\n\t\t\t\tfor(int j : adj[v]){\n\t\t\t\t\tif(col[j] == c)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tif(col[j] == -1){\n\t\t\t\t\t\tcol[j] = c ^ 0 ^ 1;\n\t\t\t\t\t\tq.push({j, col[j]});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n
kmp=bool sub(string pat, string txt){\n\tint M = pat.size();\n\tint N = txt.size();\n\tint lps[M];\n\tauto compute = [&](){\n\t\tint len = 0;\n\t\tlps[0] = 0;\n\t\tint i = 1;\n\t\twhile (i < M){\n\t\t\tif (pat[i] == pat[len]) {\n\t\t\t\tlen++;\n\t\t\t\tlps[i] = len;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (len != 0){\n\t\t\t\t\tlen = lps[len - 1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlps[i] = 0;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tcompute();\n\tint i = 0,j = 0;\n\twhile (i < N) {\n\t\tif (pat[j] == txt[i]){\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\tif (j == M){\n\t\t\t//Found pattern at index (i - j)\n\t\t\treturn true;\n\t\t\tj = lps[j - 1];\n\t\t}\n\t\telse if (i < N && pat[j] != txt[i]) {\n\t\t\tif (j != 0)j = lps[j - 1];\n\t\t\telse i = i + 1;\n\t\t}\n\t}\n\treturn false;\n}\n
sieve=vector<bool> prime;\nvoid sieve(int n_n = 1000000){\n\tprime.resize(n_n+5,true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i*i <= n_n; i++){\n\t\tif(!prime[i])continue;\n\t\tfor(int j = 2; i*j <= n_n; j++){\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n}\n
factor=vector<int> smallest_factor;\nvector<bool> prime;\nvector<int> primes;\nvoid sieve(int maximum = 1e6) {\n\tmaximum = max(maximum, 1);\n\tsmallest_factor.assign(maximum + 1, 0);\n\tprime.assign(maximum + 1, true);\n\tprime[0] = prime[1] = false;\n\tprimes = {};\n\tfor(int p = 2; p <= maximum; p++){\n\t\tif(prime[p]) {\n\t\t\tsmallest_factor[p] = p;\n\t\t\tprimes.push_back(p);\n\t\t\tfor(ll i = (ll)(p) * p; i <= maximum; i += p){\n\t\t\t\tif (prime[i]) {\n\t\t\t\t\tprime[i] = false;\n\t\t\t\t\tsmallest_factor[i] = p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n// Prime factorizes n in worst case O(sqrt n / log n). Requires having run `sieve` up to at least sqrt(n).\n// If we've run `sieve` up to at least n, takes O(log n) time.\nvector<pair<ll, int>> prime_factorize(ll n){ // Prime,exponent\n\tll sieve_max = (ll)(smallest_factor.size()) - 1;\n\tassert(1 <= n && n <= sieve_max * sieve_max);\n\tvector<pair<ll, int>> result;\n\tif(n <= sieve_max){\n\t\twhile(n != 1){\n\t\t\tll p = smallest_factor[n];\n\t\t\tint exponent = 0;\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\texponent++;\n\t\t\t} while (n % p == 0);\n\t\t\tresult.emplace_back(p, exponent);\n\t\t}\n\t\treturn result;\n\t}\n\tfor(ll p : primes){\n\t\tif(p * p > n)\n\t\t\tbreak;\n\t\tif(n % p == 0){\n\t\t\tresult.emplace_back(p, 0);\n\t\t\tdo{\n\t\t\t\tn /= p;\n\t\t\t\tresult.back().second++;\n\t\t\t} while (n % p == 0);\n\t\t}\n\t}\n\tif(n > 1)\n\t\tresult.emplace_back(n, 1);\n\treturn result;\n}\n
fft=const int mod = 998244353;\n\nstruct base {\n\tdouble x, y;\n\tbase(){\n\t\tx = y = 0;\n\t}\n\tbase(double a, double b){\n\t\tx = a;\n\t\ty = b;\n\t}\n};\ninline base operator + (base a, base b) { return base(a.x + b.x, a.y + b.y); }\ninline base operator - (base a, base b) { return base(a.x - b.x, a.y - b.y); }\ninline base operator * (base a, base b) { return base(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline base conj(base a) { return base(a.x, -a.y); }\nint lim = 1;\nvector<base> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\nconst double PI = acosl(- 1.0);\nvoid ensure_base(int p){\n\tif(p <= lim) return;\n\trev.resize(1 << p);\n\tfor(int i = 0; i < (1 << p); i++)\n\t\trev[i] = (rev[i >> 1] >> 1) + ((i & 1)  <<  (p - 1));\n\troots.resize(1 << p);\n\twhile(lim < p) {\n\t\tdouble angle = 2 * PI / (1 << (lim + 1));\n\t\tfor(int i = 1 << (lim - 1); i < (1 << lim); i++){\n\t\t\troots[i << 1] = roots[i];\n\t\t\tdouble angle_i = angle * (2 * i + 1 - (1 << lim));\n\t\t\troots[(i << 1) + 1] = base(cos(angle_i), sin(angle_i));\n\t\t}\n\t\tlim++;\n\t}\n}\nvoid fft(vector<base> &a, int n = -1) {\n\tif(n == -1) n = a.size();\n\tassert((n & (n - 1)) == 0);\n\tint zeros = __builtin_ctz(n);\n\tensure_base(zeros);\n\tint shift = lim - zeros;\n\tfor(int i = 0; i < n; i++)if(i < (rev[i] >> shift)) swap(a[i], a[rev[i] >> shift]);\n\tfor(int k = 1; k < n; k <<= 1) {\n\t\tfor(int i = 0; i < n; i += 2 * k) {\n\t\t\tfor(int j = 0; j < k; j++) {\n\t\t\t\tbase z = a[i + j + k] * roots[j + k];\n\t\t\t\ta[i + j + k] = a[i + j] - z;a[i + j] = a[i + j] + z;\n\t\t\t}\n\t\t}\n\t}\n}\nvector<int> multiply(vector<int> &a, vector<int> &b, bool eq = 0){\n\tint need = a.size() + b.size() - 1;\n\tint p = 0;\n\twhile((1 << p) < need)p++;\n\tensure_base(p);\n\tint sz = 1 << p;\n\tvector<base> A, B;\n\tif(sz > (int)A.size()) A.resize(sz);\n\tfor(int i = 0; i < (int)a.size(); i++){\n\t\tint x = (a[i] % mod + mod) % mod;\n\t\tA[i] = base(x & ((1 << 15) - 1), x >> 15);\n\t}\n\tfill(A.begin() + a.size(), A.begin() + sz, base{0, 0});\n\tfft(A, sz);\n\tif(sz > (int)B.size()) B.resize(sz);\n\tif(eq) copy(A.begin(), A.begin() + sz, B.begin());\n\t\telse{\n\tfor(int i = 0; i < (int)b.size(); i++){\n\t\t\tint x = (b[i] % mod + mod) % mod;\n\t\t\tB[i] = base(x & ((1 << 15) - 1), x >> 15);\n\t\t}\n\t\tfill(B.begin() + b.size(), B.begin() + sz, base{0, 0});\n\t\tfft(B, sz);\n\t}\n\tdouble ratio = 0.25 / sz;\n\tbase r2(0,  - 1), r3(ratio, 0), r4(0,  - ratio), r5(0, 1);\n\tfor(int i = 0; i <= (sz >> 1); i++) {\n\t\tint j = (sz - i) & (sz - 1);\n\t\tbase a1 = (A[i] + conj(A[j])), a2 = (A[i] - conj(A[j])) * r2;\n\t\tbase b1 = (B[i] + conj(B[j])) * r3, b2 = (B[i] - conj(B[j])) * r4;\n\t\tif(i != j) {\n\t\t\tbase c1 = (A[j] + conj(A[i])), c2 = (A[j] - conj(A[i])) * r2;\n\t\t\tbase d1 = (B[j] + conj(B[i])) * r3, d2 = (B[j] - conj(B[i])) * r4;\n\t\t\tA[i] = c1 * d1 + c2 * d2 * r5;\n\t\t\tB[i] = c1 * d2 + c2 * d1;\n\t\t}\n\t\tA[j] = a1 * b1 + a2 * b2 * r5;\n\t\tB[j] = a1 * b2 + a2 * b1;\n\t}\n\tfft(A, sz); fft(B, sz);\n\tvector<int> res(need);\n\tfor(int i = 0; i < need; i++){\n\t\tlong long aa = A[i].x + 0.5;\n\t\tlong long bb = B[i].x + 0.5;\n\t\tlong long cc = A[i].y + 0.5;\n\t\tres[i] = (aa + ((bb % mod) << 15) + ((cc % mod) << 30))%mod;\n\t}\n\treturn res;\n}\n
traverse=int n;\nvector<vector<int>> graph;\nvector<int> Enter,Exit,order;\nvoid traverse(int root = 0,int par = -1){\n\torder.clear();\n\tEnter.clear();Enter.resize(n);\n\tExit.clear();Exit.resize(n);\n\tint travel_time = 0;\n\tfunction<void(int,int)> traverse_tree = [&](int i, int parent){\n\t\torder.push_back(i);\n\t\tEnter[i] = travel_time++;\n\t\tfor(int node : graph[i]){\n\t\t\tif(node != parent){\n\t\t\t\ttraverse_tree(node,i);\n\t\t\t}\n\t\t}\n\t\tExit[i] = travel_time++;\n\t};traverse_tree(root,par);\n}\n\nbool anc(int child, int ancestor){ // If ansector is an ancestor of child\n\treturn Enter[ancestor] < Enter[child] && Exit[child] < Exit[ancestor];\n}\n
scc=vector<vector<int>> scc;\nvector<int> comp;\n\nvoid SCC(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tcomp.resize(V);\n\tint *disc = new int[V];\n\tint *low = new int[V];\n\tbool *stackMember = new bool[V];\n\tstack<int> *st = new stack<int>();\n\tfor (int i = 0; i < V; i++){\n\t\tdisc[i] = -1;\n\t\tlow[i] = -1;\n\t\tstackMember[i] = false;\n\t}\n\tstatic int time = 0;\n\tfunction<void(int)> find_scc = [&](int u){\n\t\tdisc[u] = low[u] = ++time;\n\t\tst->push(u);\n\t\tstackMember[u] = true;\n\t\tfor (auto i = adj[u].begin(); i != adj[u].end(); ++i){\n\t\t\tint v = *i;\n\t\t\tif (disc[v] == -1){\n\t\t\t\tfind_scc(v);\n\t\t\t\tlow[u]  = min(low[u], low[v]);\n\t\t\t}\n\t\t\telse if (stackMember[v])\n\t\t\t\tlow[u]  = min(low[u], disc[v]);\n\t\t}\n\t\tint w = 0;\n\t\tif (low[u] == disc[u]){\n\t\t\tvector<int> row;\n\t\t\tint ID = scc.size();\n\t\t\twhile (st->top() != u){\n\t\t\t\tw = (int) st->top();\n\t\t\t\trow.push_back(w);\n\t\t\t\tcomp[w] = ID;\n\t\t\t\tstackMember[w] = false;\n\t\t\t\tst->pop();\n\t\t\t}\n\t\t\tw = (int) st->top();\n\t\t\trow.push_back(w);\n\t\t\tcomp[w] = ID;\n\t\t\tscc.push_back(row);\n\t\t\tstackMember[w] = false;\n\t\t\tst->pop();\n\t\t}\n\t};\n\tfor (int i = 0; i < V; i++){\n\t\tif (disc[i] == -1)find_scc(i);\n\t}\n}\n
toposort=vector<int> toposort(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tstack<int> Stack;\n\tvector<bool> visited(V,false);\n\tfunction<void(int)> toposort = [&](int v) -> void {\n\t\tvisited[v] = true;\n\t\tfor(auto i : adj[v])\n\t\t\tif(!visited[i])\n\t\t\t\ttoposort(i);\n\t\tStack.push(v);\n\t};\n\tfor(int i = 0; i < V; i++)\n\t\tif (!visited[i])\n\t\t\ttoposort(i);\n\tvector<int> ans;\n\twhile(Stack.empty() == false) {\n\t\tans.push_back(Stack.top());\n\t\tStack.pop();\n\t}\n\treturn ans;\n}\n
cycleu=//This detects cycle in an ***undirected graph***\nvector<int> cyc;\nbool isCyclic(vector<vector<int>> &adj){\n\tint V = adj.size();\n\tbool *visited = new bool[V];\n\tfor(int i = 0; i < V; i++){\n\t\tvisited[i] = false;\n\t}\n\tfunction<bool(int,int)> cycle = [&](int v,int parent) -> bool {\n\t\tcyc.push_back(v);\n\t\tvisited[v] = true;\n\t\tfor(int i : adj[v]){\n\t\t\tif (!visited[i]){\n\t\t\t\tif(cycle(i,v)){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i != parent){\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\twhile(!cyc.empty() && cyc.back() != i)cyc.pop_back();\n\t\t\t\treverse(cyc.begin(),cyc.end());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tcyc.pop_back();\n\t\treturn false;\n\t};\n\tfor(int i = 0; i < V; i++){\n\t\tif(!visited[i] && cycle(i,-1)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n
power=ll power(ll x, ll y){\n\tll res = 1;\n\tx = x % mod;\n\tif (x == 0) return (0-0);\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\n
ncr=const int MXN = %cursor%;\nconst ll mod = %cursor%;\nll fac[MXN],invfac[MXN];\nll power(ll x, ll y){\n\tll res = 1;\n\tx = x % mod;\n\tif (x == 0) return (0-0);\n\twhile (y > 0){\n\t\tif (y & 1)\n\t\t\tres = (res*x) % mod;\n\t\ty = y >> 1;\n\t\tx = (x*x) % mod;\n\t}\n\treturn res;\n}\nvoid prep(){ // Don't forget to call this\n\tfac[0] = 1;\n\tfor(int i = 1; i < MXN; i++){\n\t\tfac[i] = fac[i-1]*i;\n\t\tfac[i] %= mod;\n\t}\n\tinvfac[MXN-1] = power(fac[MXN-1],mod-2);\n\tfor(int i = MXN-2; i >= 0; i--){\n\t\tinvfac[i] = invfac[i+1]*(i+1);\n\t\tinvfac[i] %= mod;\n\t}\n}\nll C(int n,int r){\n\tif(n < r)return (0-0);\n\treturn ((fac[n]*invfac[r])%mod * invfac[n-r])%mod;\n}\n
zfun=vector<int> z_function(string s) {\n\tint n = (int) s.length();\n\tvector<int> z(n);\n\tfor (int i = 1, l = 0, r = 0; i < n; ++i) {\n\t\tif (i <= r)\n\t\t\tz[i] = min (r - i + 1, z[i - l]);\n\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]])\n\t\t\t++z[i];\n\t\tif (i + z[i] - 1 > r)\n\t\t\tl = i, r = i + z[i] - 1;\n\t}\n\treturn z;\n}\n
suffix=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n
lcp=vector<int> sort_cyclic_shifts(string const& s){\n\tint n = s.size();\n\tconst int alphabet = 256;\n\tvector<int> p(n), c(n), cnt(max(alphabet, n), 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[s[i]]++;\n\tfor (int i = 1; i < alphabet; i++)\n\t\tcnt[i] += cnt[i-1];\n\tfor (int i = 0; i < n; i++)\n\t\tp[--cnt[s[i]]] = i;\n\tc[p[0]] = 0;\n\tint classes = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[p[i]] != s[p[i-1]])\n\t\t\tclasses++;\n\t\tc[p[i]] = classes - 1;\n\t}\n\tvector<int> pn(n), cn(n);\n\tfor (int h = 0; (1 << h) < n; ++h) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpn[i] = p[i] - (1 << h);\n\t\t\tif (pn[i] < 0)\n\t\t\t\tpn[i] += n;\n\t\t}\n\t\tfill(cnt.begin(), cnt.begin() + classes, 0);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[c[pn[i]]]++;\n\t\tfor (int i = 1; i < classes; i++)\n\t\t\tcnt[i] += cnt[i-1];\n\t\tfor (int i = n-1; i >= 0; i--)\n\t\t\tp[--cnt[c[pn[i]]]] = pn[i];\n\t\tcn[p[0]] = 0;\n\t\tclasses = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tpair<int, int> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};\n\t\t\tpair<int, int> prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};\n\t\t\tif (cur != prev)\n\t\t\t\t++classes;\n\t\t\tcn[p[i]] = classes - 1;\n\t\t}\n\t\tc.swap(cn);\n\t}\n\treturn p;\n}\n\nvector<int> suffix_array(string s) {\n\ts += "$";\n\tvector<int> sorted_shifts = sort_cyclic_shifts(s);\n\tsorted_shifts.erase(sorted_shifts.begin());\n\treturn sorted_shifts;\n}\n\n \nvector<int> lcp(string txt){\n\tint n = txt.size();\n\tvector<int> lcp(n, 0);\n\tvector<int> invSuff(n, 0);\n\tvector<int> suffixArr = suffix_array(txt);\n\tfor(int i = 0; i < n; i++)\n\t\tinvSuff[suffixArr[i]] = i;\n\tint k = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tif (invSuff[i] == n-1){\n\t\t\tk = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tint j = suffixArr[invSuff[i]+1];\n\t\twhile (i+k<n && j+k<n && txt[i+k]==txt[j+k])\n\t\t\tk++;\n\t\tlcp[invSuff[i]] = k;\n\t\tk -= k > 0;\n\t}\n\treturn lcp;\n}\n

# One line shorthands
f=first
s=second
b=begin()
e=end()
be=%cursor%.begin(),%cursor%.end()
find=find(%cursor%) != %cursor%.end()
nfind=find(%cursor%) == %cursor%.end()
re=resize(%cursor%);
pb=push_back
mp=make_pair
ppb=pop_back()
sort=sort(%cursor%.begin(),%cursor%.end());
rsort=sort(%cursor%.rbegin(),%cursor%.rend());
sortcst=sort(%cursor%.begin(),%cursor%.end(),[&](const auto &v1,const auto &v2){\n\treturn %cursor%; // (v1 < v2) : if true then v1 is before v2\n});\n
reverse=reverse(%cursor%.begin(),%cursor%.end());
unique=%cursor%.erase(unique(%cursor%.begin(), %cursor%.end()), %cursor%.end()); // Vector MUST be sorted
lb=lower_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value >= val\n
ub=upper_bound(%cursor%.begin(),%cursor%.end(),%cursor%); // returns first value > val\n
fast=ios::sync_with_stdio(false);cin.tie(0);
skl=#ifdef shivang_ka_laptop\n\t%cursor%\n#endif\n
[Kotlin]
test=import java.lang.AssertionError\n\nprivate fun readLn() = readLine()!! // string line\nprivate fun readInt() = readLn().toInt() // single int\nprivate fun readLong() = readLn().toLong() // single long\nprivate fun readDouble() = readLn().toDouble() // single double\nprivate fun readStrings() = readLn().split(" ") // list of strings\nprivate fun readInts() = readStrings().map { it.toInt() } // list of ints\nprivate fun readLongs() = readStrings().map { it.toLong() } // list of longs\nprivate fun readDoubles() = readStrings().map { it.toDouble() } // list of doubles\n\nprivate fun myAssert(x: Boolean) {\n    if (!x) {\n        throw AssertionError()\n    }\n}\n\nfun testcase(){\n\t%cursor%\n}\n\nfun main() {\n\tvar tt = readInt()\n    for (qq in 0 until tt) {\n        testcase()\n    }\n}\n
vi=var %cursor%: MutableList<Int> = mutableListOf<Int>()
vs=var %cursor%: MutableList<String> = mutableListOf<String>()

[Spice]
test= 190040112 %cursor%\n* // Refer here for help -> https://github.com/analoglab/ee230_AnalogLab_autumn2021\n\n* //Include models\n* //.include models/...\n\n* //Describe circuit\n* //<element-name> <nodes> <values/model>\n\n* //Analysis Command\n\n.control\n\nrun\n* //display command\n\n.endc\n.end\n

#[C]

#[Java]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (int i = 0; i < %cursor%; i++)%brace_open%\n%brace_close%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%
#{=%\n{\n\t%cursor%\n}%
#[PHP]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for ($i = 0; $i < %cursor%; $i++)%brace_open%\n%brace_close%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[Javascript]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[C#]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[Vala]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[ActionScript]
#if=if (%cursor%)%block_cursor%
#else=else%block_cursor%
#for=for (i = 0; i < %cursor%; i++)%block_cursor%
#while=while (%cursor%)%block_cursor%
#do=do\n{\n\t%cursor%\n} while (%cursor%)\n
#switch=switch (%cursor%)%brace_open%case %cursor%:\n\t\t%cursor%\n\t\tbreak;\n\tdefault:\n\t\t%cursor%\n%brace_close%
#try=try%block%\ncatch (%cursor%)%block_cursor%

#[Python]
#for=for i in range(%cursor%):\n\t
#if=if %cursor%:\n\t
#elif=elif %cursor%:\n\t
#else=else:\n\t
#while=while %cursor%:\n\t
#try=try:\n\t%cursor%\nexcept Exception, ex:\n\t
#with=with %cursor%:\n\t
#def=def %cursor% (%cursor%):\n\t""" Function doc """\n\t
#class=class %cursor%:\n\t""" Class doc """\n\t\n\tdef __init__ (self):\n\t\t""" Class initialiser """\n\t\tpass

#[Ferite]
#iferr=iferr%block_cursor%fix%block%
#monitor=monitor%block_cursor%handle%block%

#[Haskell]

#[HTML]
#table=<table>\n\t<tr>\n\t\t<td>%cursor%</td>\n\t</tr>\n</table>

#[Erlang]
#case=case %cursor% of\n\t%cursor% -> %cursor%\nend
#if=if\n\t%cursor% -> %cursor%\nend
#begin=begin\n\t%cursor%\nend
#fun=fun(%cursor%) ->\n\t%cursor%\nend
#try=try %cursor% of\n\t%cursor% ->\n\t%cursor%\ncatch\n\t%cursor% ->\n\t%cursor%\nend
#module=-module(%cursor%).
#export=-export(%cursor%).
#compile=-compile(%cursor%).
#include=-include(%cursor%).
